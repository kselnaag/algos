
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>amath: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kselnaag/algos/amath/math.go (98.4%)</option>
				
				<option value="file1">github.com/kselnaag/algos/array/func.go (100.0%)</option>
				
				<option value="file2">github.com/kselnaag/algos/array/hmap.go (91.5%)</option>
				
				<option value="file3">github.com/kselnaag/algos/array/pq.go (96.8%)</option>
				
				<option value="file4">github.com/kselnaag/algos/array/sort.go (83.2%)</option>
				
				<option value="file5">github.com/kselnaag/algos/array/stack.go (100.0%)</option>
				
				<option value="file6">github.com/kselnaag/algos/graph/uf.go (96.0%)</option>
				
				<option value="file7">github.com/kselnaag/algos/list/cache3A.go (0.0%)</option>
				
				<option value="file8">github.com/kselnaag/algos/list/func.go (100.0%)</option>
				
				<option value="file9">github.com/kselnaag/algos/list/hmap.go (94.2%)</option>
				
				<option value="file10">github.com/kselnaag/algos/list/stack.go (96.5%)</option>
				
				<option value="file11">github.com/kselnaag/algos/sync/sync.go (95.8%)</option>
				
				<option value="file12">github.com/kselnaag/algos/tree/aatree.go (93.0%)</option>
				
				<option value="file13">github.com/kselnaag/algos/tree/pq.go (0.0%)</option>
				
				<option value="file14">github.com/kselnaag/algos/tree/rbtree.go (94.7%)</option>
				
				<option value="file15">github.com/kselnaag/algos/types/equals.go (47.2%)</option>
				
				<option value="file16">github.com/kselnaag/algos/types/types.go (93.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package amath

import (
        "fmt"

        I "github.com/kselnaag/algos/types"
)

func HashELF(mess []byte) uint32 <span class="cov2" title="3">{
        var hash uint32 = 0
        mlen := len(mess)
        for i := 0; i &lt; mlen; i++ </span><span class="cov5" title="22">{
                hash = (hash &lt;&lt; 4) + uint32(mess[i])
                hash ^= (hash &gt;&gt; 24) &amp; 0xf0
        }</span>
        <span class="cov2" title="3">return hash &amp; 0x0fffffff</span>
}

func HashDJB2a[R uint32 | uint64](mess []byte) (hash R) <span class="cov3" title="4">{
        hash = 5381
        mlen := len(mess)
        for i := 0; i &lt; mlen; i++ </span><span class="cov7" title="42">{
                hash = ((hash &lt;&lt; 5) + hash) ^ R(mess[i])
        }</span>
        <span class="cov3" title="4">return hash</span>
}

func HashDJB2[R uint32 | uint64](mess []byte) (hash R) <span class="cov4" title="8">{
        hash = 5381
        mlen := len(mess)
        for i := 0; i &lt; mlen; i++ </span><span class="cov7" title="46">{
                hash = ((hash &lt;&lt; 5) + hash) + R(mess[i])
        }</span>
        <span class="cov4" title="8">return hash</span>
}

func HashPirson[R uint8 | uint16 | uint32 | uint64](mess []byte) (result R) <span class="cov3" title="4">{
        T := [256]byte{
                130, 4, 133, 49, 108, 178, 125, 95, 35, 126, 41, 129, 229, 48, 6, 94, 206,
                69, 20, 194, 236, 79, 156, 67, 100, 239, 152, 149, 93, 91, 56, 8, 183, 165,
                42, 148, 114, 59, 57, 5, 112, 151, 54, 97, 109, 145, 228, 196, 250, 104,
                169, 107, 86, 64, 98, 181, 200, 58, 199, 70, 138, 179, 60, 249, 34, 123,
                30, 22, 124, 240, 201, 132, 218, 21, 74, 83, 39, 223, 73, 88, 136, 27, 0,
                10, 89, 51, 215, 251, 255, 3, 235, 241, 19, 102, 71, 38, 166, 220, 110, 23,
                232, 25, 172, 210, 142, 211, 121, 242, 75, 208, 195, 203, 226, 253, 176, 17,
                66, 158, 231, 237, 99, 254, 173, 221, 117, 139, 213, 90, 85, 45, 187, 84, 92,
                44, 164, 247, 122, 32, 127, 177, 170, 155, 111, 185, 171, 61, 76, 184, 234, 192,
                16, 106, 160, 204, 153, 161, 186, 131, 28, 137, 37, 216, 248, 55, 72, 50, 26,
                46, 53, 224, 7, 217, 189, 120, 219, 167, 119, 11, 252, 65, 135, 96, 222, 68,
                144, 214, 227, 101, 207, 103, 212, 175, 157, 141, 168, 82, 163, 47, 52, 15, 113,
                230, 245, 116, 43, 80, 246, 33, 198, 197, 146, 193, 13, 31, 24, 143, 12, 18, 118,
                14, 62, 154, 78, 81, 134, 162, 105, 63, 244, 77, 190, 209, 150, 233, 159, 202, 191,
                40, 87, 180, 188, 36, 238, 9, 140, 128, 147, 174, 1, 2, 182, 243, 29, 115, 205, 225,
        }
        rounds := 0
        switch any(result).(type) </span>{
        case uint8:<span class="cov1" title="1">
                rounds = 1</span>
        case uint16:<span class="cov1" title="1">
                rounds = 2</span>
        case uint32:<span class="cov1" title="1">
                rounds = 4</span>
        case uint64:<span class="cov1" title="1">
                rounds = 8</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("rules.HashPirson[R](mess []byte): "+
                        "Type of R is unknown, expected (uint8 | uint16 | uint32 | uint64), actual %T", result))</span>
        }
        <span class="cov3" title="4">mlen := len(mess)
        hash := T[mlen%256]
        for j := 0; j &lt; rounds; j++ </span><span class="cov5" title="15">{
                for i := 0; i &lt; mlen; i++ </span><span class="cov8" title="120">{
                        hash = T[int(hash^mess[i])]
                }</span>
                <span class="cov5" title="15">result += R(hash) &lt;&lt; (8 * j)</span>
        }
        <span class="cov3" title="4">return result</span>
}

func Harmonic(n int) float64 <span class="cov3" title="6">{
        if n &lt; 0 </span><span class="cov2" title="2">{
                panic("algos.amath.Harmonic(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov3" title="4">sum := 0.0
        for i := 1; i &lt;= n; i++ </span><span class="cov10" title="261">{
                sum += 1.0 / float64(i)
        }</span>
        <span class="cov3" title="4">return sum</span>
}

// Newton square root
func Sqrt(c float64) float64 <span class="cov3" title="6">{
        if c &lt; 0 </span><span class="cov2" title="2">{
                panic("algos.amath.Sqrt(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov3" title="4">err := 1e-15
        t := c
        for Abs(t-c/t) &gt; (err * t) </span><span class="cov6" title="28">{
                t = (c/t + t) / 2.0
        }</span>
        <span class="cov3" title="4">return t</span>
}

func IsPrime(n int) bool <span class="cov4" title="9">{
        if n &lt; 2 </span><span class="cov2" title="3">{
                return false
        }</span>
        <span class="cov3" title="6">for i := 2; (i * i) &lt;= n; i++ </span><span class="cov7" title="63">{
                if (n % i) == 0 </span><span class="cov2" title="2">{
                        return false
                }</span>
        }
        <span class="cov3" title="4">return true</span>
}

// Evklid NOD
func Gcd(p, q int) int <span class="cov4" title="10">{
        p, q = Abs(p), Abs(q)
        if q == 0 </span><span class="cov3" title="4">{
                return p
        }</span>
        <span class="cov3" title="6">r := p % q
        return Gcd(q, r)</span>
}

func Abs[T I.Signed | I.Float](val T) T <span class="cov7" title="60">{
        return Ternar((val &lt; 0), (-1 * val), val)
}</span>

func Min[T I.Ord](x, y T) T <span class="cov4" title="9">{
        return Ternar((x &lt; y), x, y)
}</span>

func Max[T I.Ord](x, y T) T <span class="cov4" title="9">{
        return Ternar((x &gt; y), x, y)
}</span>

func Ternar[T any](cond bool, a, b T) T <span class="cov8" title="86">{
        if cond </span><span class="cov5" title="18">{
                return a
        }</span>
        <span class="cov7" title="68">return b</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package array

func Map[T1, T2 any](arr []T1, fnc func(T1) T2) []T2 <span class="cov2" title="2">{
        res := make([]T2, 0, len(arr))
        for _, el := range arr </span><span class="cov6" title="10">{
                res = append(res, fnc(el))
        }</span>
        <span class="cov2" title="2">return res</span>
}

func MapA[T1, T2 any](arr []T1, fnc func(T1) T2) []T2 <span class="cov2" title="2">{
        res := make([]T2, 0, len(arr))
        chans := make([]chan T2, len(arr))
        for i, el := range arr </span><span class="cov6" title="10">{
                elemChan := make(chan T2)
                chans[i] = elemChan
                go func(elemChan chan&lt;- T2, el T1) </span><span class="cov6" title="10">{
                        elemChan &lt;- fnc(el)
                }</span>(elemChan, el)
        }
        <span class="cov2" title="2">for _, elemChan := range chans </span><span class="cov6" title="10">{
                res = append(res, &lt;-elemChan)
        }</span>
        <span class="cov2" title="2">return res</span>
}

func Reduce[T1, T2 any](arr []T1, fnc func(T2, T1) T2, acc T2) T2 <span class="cov2" title="2">{
        for _, el := range arr </span><span class="cov6" title="10">{
                acc = fnc(acc, el)
        }</span>
        <span class="cov2" title="2">return acc</span>
}

func ReduceR[T1, T2 any](arr []T1, fnc func(T2, T1) T2, acc T2) T2 <span class="cov2" title="2">{
        alen := len(arr)
        for i := alen - 1; i &gt;= 0; i-- </span><span class="cov6" title="10">{
                acc = fnc(acc, arr[i])
        }</span>
        <span class="cov2" title="2">return acc</span>
}

func Filter[T any](arr []T, fnc func(T) bool) []T <span class="cov3" title="3">{
        res := make([]T, 0)
        for _, el := range arr </span><span class="cov8" title="20">{
                if fnc(el) </span><span class="cov6" title="10">{
                        res = append(res, el)
                }</span>
        }
        <span class="cov3" title="3">return res</span>
}

func Perm[T any](a []T, f func([]T)) <span class="cov2" title="2">{
        perm(a, f, 0)
}</span>

func perm[T any](a []T, f func([]T), i int) <span class="cov10" title="44">{
        if i &gt; len(a) </span><span class="cov6" title="12">{
                f(a)
                return
        }</span>
        <span class="cov9" title="32">perm(a, f, i+1)
        for j := i + 1; j &lt; len(a); j++ </span><span class="cov6" title="10">{
                a[i], a[j] = a[j], a[i]
                perm(a, f, i+1)
                a[i], a[j] = a[j], a[i]
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package array

import (
        "github.com/kselnaag/algos/amath"
        I "github.com/kselnaag/algos/types"
)

const maxUint8 int = (1 &lt;&lt; 8)

type Anode[K I.Ord, V any] struct {
        Key K
        Val V
}

type Hmap[K I.Ord, V any] struct {
        hmarr   [maxUint8]*[]Anode[K, V]
        keysnum int
}

func NewHmap[K I.Ord, V any]() Hmap[K, V] <span class="cov1" title="1">{
        return Hmap[K, V]{
                hmarr:   [maxUint8]*[]Anode[K, V]{},
                keysnum: 0,
        }
}</span>

func (hm *Hmap[K, V]) Size() int <span class="cov4" title="8">{
        return hm.keysnum
}</span>

func (hm *Hmap[K, V]) IsEmpty() bool <span class="cov3" title="4">{
        return hm.Size() == 0
}</span>

func hashFromKey[K I.Ord](key K) int <span class="cov6" title="23">{
        bytesarr := I.ConvToByteArr(key)
        hash := amath.HashDJB2a[uint32](bytesarr)
        return int(hash &amp; 0x000000FF)
}</span>

func (hm *Hmap[K, V]) Set(key K, val V) <span class="cov4" title="11">{
        hashIdx := hashFromKey(key)
        node := Anode[K, V]{Key: key, Val: val}
        if hm.hmarr[hashIdx] == nil </span><span class="cov4" title="9">{
                hm.hmarr[hashIdx] = &amp;[]Anode[K, V]{node}
                hm.keysnum++
                return
        }</span>
        <span class="cov2" title="2">for i, hnode := range *hm.hmarr[hashIdx] </span><span class="cov2" title="2">{
                if hnode.Key == key </span><span class="cov2" title="2">{
                        (*hm.hmarr[hashIdx])[i] = node
                        return
                }</span>
        }
        <span class="cov0" title="0">*hm.hmarr[hashIdx] = append(*hm.hmarr[hashIdx], node)
        hm.keysnum++</span>
}

func (hm *Hmap[K, V]) IsKey(key K) bool <span class="cov3" title="6">{
        hashIdx := hashFromKey(key)
        if hm.hmarr[hashIdx] == nil </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov3" title="4">for _, hnode := range *hm.hmarr[hashIdx] </span><span class="cov2" title="3">{
                if hnode.Key == key </span><span class="cov2" title="3">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func (hm *Hmap[K, V]) Get(key K) V <span class="cov3" title="4">{
        hashIdx := hashFromKey(key)
        if hm.hmarr[hashIdx] == nil </span><span class="cov2" title="2">{
                panic("algos.array.(Hmap).Get(key K): No any key found, check first")</span>
        }
        <span class="cov2" title="2">for _, hnode := range *hm.hmarr[hashIdx] </span><span class="cov2" title="2">{
                if hnode.Key == key </span><span class="cov2" title="2">{
                        return hnode.Val
                }</span>
        }
        <span class="cov0" title="0">panic("algos.array.(Hmap).Get(key K): No any key found, check first")</span>
}

func (hm *Hmap[K, V]) Del(key K) <span class="cov2" title="2">{
        hashIdx := hashFromKey(key)
        if hm.hmarr[hashIdx] == nil </span><span class="cov1" title="1">{
                panic("algos.array.(Hmap).Del(key K): No any key found, check first")</span>
        }
        <span class="cov1" title="1">for i, hnode := range *hm.hmarr[hashIdx] </span><span class="cov1" title="1">{
                if hnode.Key == key </span><span class="cov1" title="1">{
                        *hm.hmarr[hashIdx] = append((*hm.hmarr[hashIdx])[:i], (*hm.hmarr[hashIdx])[i+1:]...)
                        hm.keysnum--
                        return
                }</span>
        }
        <span class="cov0" title="0">panic("algos.array.(Hmap).Del(key K): No any key found, check first")</span>
}

func (hm *Hmap[K, V]) IterateKeys() []K <span class="cov1" title="1">{
        res := []K{}
        for _, ptr := range hm.hmarr </span><span class="cov10" title="256">{
                if ptr != nil </span><span class="cov4" title="9">{
                        for _, kvnode := range *ptr </span><span class="cov4" title="8">{
                                res = append(res, kvnode.Key)
                        }</span>
                }
        }
        <span class="cov1" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package array

import (
        I "github.com/kselnaag/algos/types"
)

func swimLT[T any](arr []T, k int) <span class="cov6" title="42">{
        for (k &gt; 1) &amp;&amp; I.GT(arr[k/2], arr[k]) </span><span class="cov6" title="36">{
                swap(arr, k/2, k)
                k /= 2
        }</span>
}

func sinkLT[T any](arr []T, k, size int) <span class="cov5" title="21">{
        for (2 * k) &lt;= size </span><span class="cov5" title="21">{
                j := 2 * k
                if (j &lt; size) &amp;&amp; I.GT(arr[j], arr[j+1]) </span><span class="cov3" title="6">{
                        j++
                }</span>
                <span class="cov5" title="21">if !I.GT(arr[k], arr[j]) </span><span class="cov4" title="9">{
                        break</span>
                }
                <span class="cov4" title="12">swap(arr, k, j)
                k = j</span>
        }
}

func swimGT[T any](arr []T, k int) <span class="cov6" title="42">{
        for (k &gt; 1) &amp;&amp; I.LT(arr[k/2], arr[k]) </span><span class="cov3" title="6">{
                swap(arr, k/2, k)
                k /= 2
        }</span>
}

func sinkGT[T any](arr []T, k, size int) <span class="cov9" title="236">{
        for (2 * k) &lt;= size </span><span class="cov10" title="367">{
                j := 2 * k
                if (j &lt; size) &amp;&amp; I.LT(arr[j], arr[j+1]) </span><span class="cov8" title="146">{
                        j++
                }</span>
                <span class="cov10" title="367">if !I.LT(arr[k], arr[j]) </span><span class="cov5" title="17">{
                        break</span>
                }
                <span class="cov9" title="350">swap(arr, k, j)
                k = j</span>
        }
}

// ===========================
type MinPQ[T any] struct {
        pq   []T
        size int
}

func NewMinPQ[T any]() MinPQ[T] <span class="cov3" title="6">{
        return MinPQ[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (min *MinPQ[T]) Size() int <span class="cov6" title="30">{
        return min.size
}</span>

func (min *MinPQ[T]) IsEmpty() bool <span class="cov5" title="15">{
        return min.Size() == 0
}</span>

func (min *MinPQ[T]) swim(k int) <span class="cov6" title="42">{
        swimLT(min.pq, k)
}</span>

func (min *MinPQ[T]) sink(k int) <span class="cov5" title="21">{
        sinkLT(min.pq, k, min.size)
}</span>

func (min *MinPQ[T]) Add(val T) <span class="cov6" title="42">{
        min.size++
        if len(min.pq) &gt; min.size </span><span class="cov5" title="21">{
                min.pq[min.size] = val
        }</span> else<span class="cov5" title="21"> {
                min.pq = append(min.pq, val)
        }</span>
        <span class="cov6" title="42">min.swim(min.size)</span>
}

func (min *MinPQ[T]) Min() T <span class="cov4" title="9">{
        if min.size &lt; 1 </span><span class="cov2" title="3">{
                panic("algos.array.(MinPQ).Min(): Queue is empty ")</span>
        }
        <span class="cov3" title="6">return min.pq[1]</span>
}

func (min *MinPQ[T]) GetMin() T <span class="cov5" title="24">{
        if min.size &lt; 1 </span><span class="cov2" title="3">{
                panic("algos.array.(MinPQ).GetMin(): Queue is empty ")</span>
        }
        <span class="cov5" title="21">ret := min.pq[1]
        swap(min.pq, 1, min.size)
        min.size--
        min.sink(1)
        return ret</span>
}

func (min *MinPQ[T]) Iterate() []T <span class="cov2" title="3">{
        return min.pq[1:(min.size + 1)]
}</span>

// ===========================
type MaxPQ[T any] struct {
        pq   []T
        size int
}

func NewMaxPQ[T any]() MaxPQ[T] <span class="cov3" title="6">{
        return MaxPQ[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (max *MaxPQ[T]) Size() int <span class="cov6" title="30">{
        return max.size
}</span>

func (max *MaxPQ[T]) IsEmpty() bool <span class="cov5" title="15">{
        return max.Size() == 0
}</span>

func (max *MaxPQ[T]) swim(k int) <span class="cov6" title="42">{
        swimGT(max.pq, k)
}</span>

func (max *MaxPQ[T]) sink(k int) <span class="cov5" title="21">{
        sinkGT(max.pq, k, max.size)
}</span>

func (max *MaxPQ[T]) Add(val T) <span class="cov6" title="42">{
        max.size++
        if len(max.pq) &gt; max.size </span><span class="cov5" title="21">{
                max.pq[max.size] = val
        }</span> else<span class="cov5" title="21"> {
                max.pq = append(max.pq, val)
        }</span>
        <span class="cov6" title="42">max.swim(max.size)</span>
}

func (max *MaxPQ[T]) Max() T <span class="cov4" title="9">{
        if max.size &lt; 1 </span><span class="cov2" title="3">{
                panic("algos.array.(MaxPQ).Max(): Queue is empty ")</span>
        }
        <span class="cov3" title="6">return max.pq[1]</span>
}

func (max *MaxPQ[T]) GetMax() T <span class="cov5" title="24">{
        if max.size &lt; 1 </span><span class="cov2" title="3">{
                panic("algos.array.(MaxPQ).GetMax(): Queue is empty ")</span>
        }
        <span class="cov5" title="21">ret := max.pq[1]
        swap(max.pq, 1, max.size)
        max.size--
        max.sink(1)
        return ret</span>
}

func (max *MaxPQ[T]) Iterate() []T <span class="cov2" title="3">{
        return max.pq[1:(max.size + 1)]
}</span>

// ===========================
type LRU[T any] struct {
        arr []T
}

func NewLRU[T any](size int) LRU[T] <span class="cov1" title="1">{
        return LRU[T]{
                arr: make([]T, 0, size),
        }
}</span>

func (lru *LRU[T]) Cap() int <span class="cov4" title="9">{
        return cap(lru.arr)
}</span>

func (lru *LRU[T]) Size() int <span class="cov6" title="34">{
        return len(lru.arr)
}</span>

func (lru *LRU[T]) IsEmpty() bool <span class="cov2" title="3">{
        return lru.Size() == 0
}</span>

func (lru *LRU[T]) Iterate() []T <span class="cov3" title="4">{
        return lru.arr
}</span>

func (lru *LRU[T]) binsrchLT(arr []T, pidx int) int <span class="cov4" title="8">{
        low := 0
        high := len(arr) - 1
        elem := arr[pidx]
        mid := 0
        for low &lt; high </span><span class="cov5" title="16">{
                mid = (low + ((high - low) / 2))
                val := arr[mid]
                switch </span>{
                case I.EQ(val, elem):<span class="cov0" title="0">
                        return mid</span>
                case I.GT(val, elem):<span class="cov4" title="10">
                        high = mid</span>
                case I.LT(val, elem):<span class="cov3" title="6">
                        low = mid + 1</span>
                default:<span class="cov0" title="0">
                        panic("algos.array.(LRU).binsrchLT(arr, pidx): comparison failed")</span>
                }
        }
        <span class="cov4" title="8">return mid</span>
}

func (lru *LRU[T]) sortpoint(pidx int) <span class="cov4" title="8">{
        val := lru.arr[pidx]
        inspos := lru.binsrchLT(lru.arr, pidx)
        if I.LT(lru.arr[inspos], val) </span><span class="cov3" title="5">{
                inspos++
        }</span>
        <span class="cov4" title="8">for i := lru.Size() - 2; i &gt;= inspos; i-- </span><span class="cov5" title="17">{
                lru.arr[i+1] = lru.arr[i]
        }</span>
        <span class="cov4" title="8">lru.arr[inspos] = val</span>
}

func (lru *LRU[T]) Set(val T) <span class="cov4" title="9">{
        if lru.Size() == lru.Cap() </span><span class="cov2" title="2">{
                if !I.LT(val, lru.arr[lru.Size()-1]) </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov1" title="1">lru.arr[lru.Size()-1] = val</span>
        } else<span class="cov3" title="7"> {
                lru.arr = append(lru.arr, val)
        }</span>
        <span class="cov4" title="8">lru.sortpoint(lru.Size() - 1)</span>
}

// ===========================
type MRU[T any] struct {
        arr []T
}

func NewMRU[T any](size int) MRU[T] <span class="cov1" title="1">{
        return MRU[T]{
                arr: make([]T, 0, size),
        }
}</span>

func (mru *MRU[T]) Cap() int <span class="cov4" title="9">{
        return cap(mru.arr)
}</span>

func (mru *MRU[T]) Size() int <span class="cov6" title="34">{
        return len(mru.arr)
}</span>

func (mru *MRU[T]) IsEmpty() bool <span class="cov2" title="3">{
        return mru.Size() == 0
}</span>

func (mru *MRU[T]) Iterate() []T <span class="cov3" title="4">{
        return mru.arr
}</span>

func (mru *MRU[T]) binsrchGT(arr []T, pidx int) int <span class="cov4" title="8">{
        low := 0
        high := len(arr) - 1
        elem := arr[pidx]
        mid := 0
        for low &lt; high </span><span class="cov5" title="16">{
                mid = (low + ((high - low) / 2))
                val := arr[mid]
                switch </span>{
                case I.EQ(val, elem):<span class="cov0" title="0">
                        return mid</span>
                case I.LT(val, elem):<span class="cov3" title="7">
                        high = mid</span>
                case I.GT(val, elem):<span class="cov4" title="9">
                        low = mid + 1</span>
                default:<span class="cov0" title="0">
                        panic("algos.array.(LRU).binsrchLT(arr, pidx): comparison failed")</span>
                }
        }
        <span class="cov4" title="8">return mid</span>
}

func (mru *MRU[T]) sortpoint(pidx int) <span class="cov4" title="8">{
        val := mru.arr[pidx]
        inspos := mru.binsrchGT(mru.arr, pidx)
        if I.GT(mru.arr[inspos], val) </span><span class="cov3" title="5">{
                inspos++
        }</span>
        <span class="cov4" title="8">for i := mru.Size() - 2; i &gt;= inspos; i-- </span><span class="cov4" title="10">{
                mru.arr[i+1] = mru.arr[i]
        }</span>
        <span class="cov4" title="8">mru.arr[inspos] = val</span>
}

func (mru *MRU[T]) Set(val T) <span class="cov4" title="9">{
        if mru.Size() == mru.Cap() </span><span class="cov2" title="2">{
                if !I.GT(val, mru.arr[mru.Size()-1]) </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov1" title="1">mru.arr[mru.Size()-1] = val</span>
        } else<span class="cov3" title="7"> {
                mru.arr = append(mru.arr, val)
        }</span>
        <span class="cov4" title="8">mru.sortpoint(mru.Size() - 1)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package array

import (
        "math/rand"

        I "github.com/kselnaag/algos/types"
)

func Quick3Sort[T any](arr []T) <span class="cov5" title="43">{
        Shuffle(arr)
        q3sort(arr, 0, len(arr)-1)
}</span>

func q3sort[T any](arr []T, lo, hi int) <span class="cov7" title="285">{
        if hi &lt;= lo </span><span class="cov6" title="164">{
                return
        }</span>
        <span class="cov6" title="121">l, i, v, g := lo, lo+1, arr[lo], hi
        for i &lt;= g </span><span class="cov7" title="487">{
                switch </span>{
                case I.LT(arr[i], v):<span class="cov7" title="258">
                        swap(arr, l, i)
                        l++
                        i++</span>
                case I.GT(arr[i], v):<span class="cov7" title="229">
                        swap(arr, i, g)
                        g--</span>
                default:<span class="cov0" title="0">
                        i++</span>
                }
        }
        <span class="cov6" title="121">q3sort(arr, lo, l-1)
        q3sort(arr, g+1, hi)</span>
}

func HeapSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        for k := alen / 2; k &gt; 0; k-- </span><span class="cov5" title="87">{
                sinkGT(arr, k, alen-1)
        }</span>
        <span class="cov5" title="43">for n := alen - 1; n &gt; 1; </span><span class="cov6" title="128">{
                swap(arr, 1, n)
                n--
                sinkGT(arr, 1, n)
        }</span>
}

func QuickSort[T any](arr []T) <span class="cov5" title="43">{
        Shuffle(arr)
        qsort(arr, 0, len(arr)-1)
}</span>

func qsort[T any](arr []T, lo, hi int) <span class="cov6" title="127">{
        if hi &lt;= lo </span><span class="cov5" title="50">{
                return
        }</span>
        <span class="cov5" title="77">if (hi - lo + 1) &lt;= 12 </span><span class="cov4" title="35">{
                InsertSort(arr)
                return
        }</span>
        <span class="cov5" title="42">j := pivot(arr, lo, hi)
        qsort(arr, lo, j-1)
        qsort(arr, j+1, hi)</span>
}

func pivot[T any](arr []T, lo, hi int) int <span class="cov5" title="42">{
        i, j, v := lo, hi, lo
        for </span><span class="cov6" title="180">{
                for ; I.LT(arr[i], arr[v]); i++ </span><span class="cov0" title="0">{
                        if i == hi </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov6" title="180">for ; I.LT(arr[v], arr[j]); j-- </span><span class="cov8" title="777">{
                        if j == lo </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov6" title="180">if i &gt;= j </span><span class="cov5" title="42">{
                        break</span>
                }
                <span class="cov6" title="138">swap(arr, i, j)</span>
        }
        <span class="cov5" title="42">swap(arr, lo, j)
        return j</span>
}

func MergeSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        aux := make([]T, alen)
        copy(aux, arr)
        mrgsort(aux, arr, 0, alen-1)
}</span>

func mrgsort[T any](src, dst []T, lo, hi int) <span class="cov5" title="61">{
        if hi &lt;= lo </span><span class="cov3" title="8">{
                return
        }</span>
        <span class="cov5" title="53">if (hi - lo + 1) &lt;= 12 </span><span class="cov5" title="44">{
                InsertSort(src[lo : hi+1])
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov3" title="9">mid := lo + (hi-lo)/2
        mrgsort(dst, src, lo, mid)
        mrgsort(dst, src, mid+1, hi)
        merge(src, dst, lo, mid, hi)</span>
}

func merge[T any](src, dst []T, lo, mid, hi int) <span class="cov3" title="9">{
        if !I.GT(src[mid], src[mid+1]) </span><span class="cov3" title="9">{
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov0" title="0">i, j := lo, mid+1
        for k := lo; k &lt;= hi; k++ </span><span class="cov0" title="0">{
                if i &gt; mid </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                        continue</span>
                }
                <span class="cov0" title="0">if j &gt; hi </span><span class="cov0" title="0">{
                        dst[k] = src[i]
                        i++
                        continue</span>
                }
                <span class="cov0" title="0">if I.LT(src[j], src[i]) </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                }</span> else<span class="cov0" title="0"> {
                        dst[k] = src[i]
                        i++
                }</span>
        }
}

func ReverseSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov5" title="87">{
                min := i
                max := i
                for j := 1 + i; j &lt; (alen - i); j++ </span><span class="cov8" title="635">{
                        if I.LT(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                        <span class="cov8" title="635">if I.GT(arr[j], arr[max]) </span><span class="cov8" title="635">{
                                max = j
                        }</span>
                }
                <span class="cov5" title="87">if (max == i) &amp;&amp; (min == (alen - 1 - i)) </span><span class="cov0" title="0">{
                        swap(arr, min, max)
                }</span> else<span class="cov5" title="87"> {
                        swap(arr, min, i)
                        swap(arr, max, alen-1-i)
                }</span>
        }
}

func SelectSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov6" title="203">{
                min := i
                for j := i + 1; j &lt; alen; j++ </span><span class="cov8" title="1183">{
                        if I.LT(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                }
                <span class="cov6" title="203">swap(arr, i, min)</span>
        }
}

func ShellSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        h := 1
        for h &lt; (alen / 3) </span><span class="cov3" title="14">{
                h = 3*h + 1
        }</span>
        <span class="cov5" title="43">for h &gt; 0 </span><span class="cov5" title="57">{
                for i := h; i &lt; alen; i++ </span><span class="cov7" title="288">{
                        for j := i; j &gt;= h; j -= h </span><span class="cov7" title="288">{
                                if I.LT(arr[j], arr[j-h]) </span><span class="cov0" title="0">{
                                        swap(arr, j, j-h)
                                }</span> else<span class="cov7" title="288"> {
                                        break</span>
                                }
                        }
                }
                <span class="cov5" title="57">h /= 3</span>
        }
}

func InsertSort[T any](arr []T) <span class="cov6" title="122">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov7" title="480">{
                for j := i; j &gt; 0; j-- </span><span class="cov9" title="1590">{
                        if I.LT(arr[j], arr[j-1]) </span><span class="cov8" title="1249">{
                                swap(arr, j, j-1)
                        }</span> else<span class="cov7" title="341"> {
                                break</span>
                        }
                }
        }
}

func BinarySearch[T any](arr []T, elem T) int <span class="cov2" title="3">{
        low := 0
        high := len(arr) - 1
        for low &lt; high </span><span class="cov2" title="5">{
                mid := (low + ((high - low) / 2))
                val := arr[mid]
                switch </span>{
                case I.GT(val, elem):<span class="cov0" title="0">
                        high = mid</span>
                case I.LT(val, elem):<span class="cov2" title="4">
                        low = mid + 1</span>
                default:<span class="cov1" title="1">
                        return mid</span>
                }
        }
        <span class="cov1" title="2">return -1</span>
}

func Shuffle[T any](arr []T) <span class="cov5" title="88">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov7" title="419">{
                j := rand.Intn(i + 1) //nolint:gosec // simple `math.rand` enough for sorting
                swap(arr, i, j)
        }</span>
}

func Reverse[T any](arr []T) <span class="cov3" title="9">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov4" title="27">{
                swap(arr, i, alen-i-1)
        }</span>
}

func Contained[T any](arr []T, elem T) int <span class="cov2" title="3">{
        for i, el := range arr </span><span class="cov2" title="6">{
                if I.EQ(el, elem) </span><span class="cov1" title="1">{
                        return i
                }</span>
        }
        <span class="cov1" title="2">return -1</span>
}

func IsSorted[T any](arr []T) bool <span class="cov2" title="4">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov3" title="14">{
                if I.LT(arr[i], arr[i-1]) </span><span class="cov1" title="2">{
                        return false
                }</span>
        }
        <span class="cov1" title="2">return true</span>
}

func swap[T any](arr []T, i, j int) <span class="cov10" title="3313">{
        arr[i], arr[j] = arr[j], arr[i]
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package array

// ===========================
type Bag[T any] struct {
        arr  []T
        size int
}

func NewBag[T any]() Bag[T] <span class="cov1" title="1">{
        return Bag[T]{
                arr:  make([]T, 0, 8),
                size: 0,
        }
}</span>

func (b *Bag[T]) Size() int <span class="cov7" title="6">{
        return b.size
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov4" title="3">{
        return b.Size() == 0
}</span>

func (b *Bag[T]) Add(val T) <span class="cov7" title="7">{
        b.arr = append(b.arr, val)
        b.size++
}</span>

func (b *Bag[T]) Iterate() []T <span class="cov3" title="2">{
        return b.arr
}</span>

func (b *Bag[T]) Reverse() <span class="cov1" title="1">{
        Reverse(b.arr)
}</span>

// ===========================
type Stack[T any] struct {
        arr  []T
        size int
}

func NewStack[T any]() Stack[T] <span class="cov3" title="2">{
        return Stack[T]{
                arr:  make([]T, 0, 8),
                size: 0,
        }
}</span>

func (s *Stack[T]) Size() int <span class="cov8" title="9">{
        return s.size
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov5" title="4">{
        return s.Size() == 0
}</span>

func (s *Stack[T]) Push(val T) <span class="cov10" title="14">{
        s.arr = append(s.arr, val)
        s.size++
}</span>

func (s *Stack[T]) Pop() T <span class="cov8" title="8">{
        last := len(s.arr) - 1
        ret := s.arr[last]
        s.arr = s.arr[:last]
        s.size--
        return ret
}</span>

func (s *Stack[T]) Iterate() []T <span class="cov1" title="1">{
        return s.arr
}</span>

func (s *Stack[T]) Reverse() <span class="cov1" title="1">{
        Reverse(s.arr)
}</span>

// ===========================
type Queue[T any] struct {
        arr  []T
        size int
}

func NewQueue[T any]() Queue[T] <span class="cov3" title="2">{
        return Queue[T]{
                arr:  make([]T, 0, 8),
                size: 0,
        }
}</span>

func (q *Queue[T]) Size() int <span class="cov8" title="9">{
        return q.size
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov5" title="4">{
        return q.Size() == 0
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov10" title="14">{
        q.arr = append(q.arr, val)
        q.size++
}</span>

func (q *Queue[T]) Deq() T <span class="cov8" title="8">{
        ret := q.arr[0]
        q.arr = q.arr[1:]
        q.size--
        return ret
}</span>

func (q *Queue[T]) Iterate() []T <span class="cov1" title="1">{
        return q.arr
}</span>

func (q *Queue[T]) Reverse() <span class="cov1" title="1">{
        Reverse(q.arr)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package graph

import (
        "github.com/kselnaag/algos/amath"
        "github.com/kselnaag/algos/array"
)

type UF struct {
        id    []int
        bag   array.Bag[int]
        count int
        size  int
}

func NewUF(n int) UF <span class="cov1" title="1">{
        n = amath.Abs(n)
        arr := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov6" title="10">{
                arr[i] = i
        }</span>
        <span class="cov1" title="1">return UF{
                id:    arr,
                bag:   array.NewBag[int](),
                count: n,
                size:  n,
        }</span>
}

func (uf *UF) Union(p, q int) <span class="cov5" title="8">{
        pRoot := uf.Find(p)
        qRoot := uf.Find(q)
        if pRoot == qRoot </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="8">uf.id[qRoot] = pRoot
        uf.count--</span>
}

func (uf *UF) Find(p int) int <span class="cov10" title="50">{
        p = amath.Abs(p)
        for p != uf.id[p] </span><span class="cov8" title="29">{
                uf.bag.Add(p)
                p = uf.id[p]
        }</span>
        // path compression
        <span class="cov10" title="50">blen := uf.bag.Size()
        barr := uf.bag.Iterate()
        for i := 0; i &lt; blen; i++ </span><span class="cov8" title="29">{
                t := barr[i]
                uf.id[t] = p
        }</span>
        <span class="cov10" title="50">uf.bag = array.NewBag[int]()
        return p</span>
}

func (uf *UF) Connected(p, q int) bool <span class="cov5" title="7">{
        return uf.Find(p) == uf.Find(q)
}</span>

func (uf *UF) Count() int <span class="cov3" title="3">{
        return uf.count
}</span>

func (uf *UF) Size() int <span class="cov3" title="3">{
        return uf.size
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package list

import (
        "sync/atomic"
        "time"

        I "github.com/kselnaag/algos/types"
)

const maxUint8 int = (1 &lt;&lt; 8)

type LMnode[K I.Ord, V any] struct {
        LongKey   K
        LongExpr  time.Time
        ShortKey  K
        ShortExpr time.Time
        Val       V
        Next      *LMnode[K, V]
}

type SMnode[K I.Ord, V any] struct {
        ShortKey  K
        ShortExpr time.Time
        Link      *LMnode[K, V]
        Next      *SMnode[K, V]
}

type Cache3A[K I.Ord, V any] struct {
        lmarr    [maxUint8]*LMnode[K, V]
        smarr    [maxUint8]*SMnode[K, V]
        lkeysnum atomic.Uint32
        // mu       sync.RWMutex
}

func NewCache3A[K I.Ord, V any]() *Cache3A[K, V] <span class="cov0" title="0">{
        return &amp;Cache3A[K, V]{
                lmarr: [maxUint8]*LMnode[K, V]{},
                smarr: [maxUint8]*SMnode[K, V]{},
        }
}</span>

func (c *Cache3A[K, V]) Size() int <span class="cov0" title="0">{
        return int(c.lkeysnum.Load())
}</span>

func (c *Cache3A[K, V]) IsEmpty() bool <span class="cov0" title="0">{
        return (c.Size() == 0)
}</span>

/* func hashFromKeys[K I.Ord](key K) int {
        bytesarr := I.ConvToByteArr(key)
        hash := A.HashDJB2a[uint32](bytesarr)
        return int(hash &amp; 0x000000FF)
} */

func (c *Cache3A[K, V]) SetLong(long K, val V) {<span class="cov0" title="0">
        //
}</span>

func (c *Cache3A[K, V]) SetShort(short, long K) {<span class="cov0" title="0">

}</span>

func (c *Cache3A[K, V]) GetLong(long K) *V <span class="cov0" title="0">{
        return nil
}</span>

func (c *Cache3A[K, V]) GetShort(short K) *V <span class="cov0" title="0">{
        return nil
}</span>

func (c *Cache3A[K, V]) DelLong(long K) {<span class="cov0" title="0">

}</span>

func (c *Cache3A[K, V]) DelShort(short K) {<span class="cov0" title="0">

}</span>

func (c *Cache3A[K, V]) IterateLongKeys() []K <span class="cov0" title="0">{
        return []K{}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package list

func Map[T1, T2 any](root *Snode[T1], fnc func(T1) T2) *Snode[T2] <span class="cov5" title="6">{
        var res, ptr *Snode[T2]
        for onode := root; onode != nil; onode = onode.Next </span><span class="cov9" title="40">{
                nnode := &amp;Snode[T2]{Val: fnc(onode.Val), Next: nil}
                if onode == root </span><span class="cov4" title="5">{
                        res = nnode
                }</span> else<span class="cov9" title="35"> {
                        ptr.Next = nnode
                }</span>
                <span class="cov9" title="40">ptr = nnode</span>
        }
        <span class="cov5" title="6">return res</span>
}

func MapA[T1, T2 any](root *Snode[T1], fnc func(T1) T2) *Snode[T2] <span class="cov2" title="2">{
        llen := ListSize(root)
        chans := make([]chan T2, llen)
        i := 0
        for node := root; node != nil; node = node.Next </span><span class="cov6" title="10">{
                elemChan := make(chan T2)
                chans[i] = elemChan
                i++
                go func(elemChan chan&lt;- T2, el T1) </span><span class="cov6" title="10">{
                        elemChan &lt;- fnc(el)
                }</span>(elemChan, node.Val)
        }
        <span class="cov2" title="2">var res, ptr *Snode[T2]
        for i, elemChan := range chans </span><span class="cov6" title="10">{
                node := &amp;Snode[T2]{Val: &lt;-elemChan, Next: nil}
                if i == 0 </span><span class="cov1" title="1">{
                        res = node
                }</span> else<span class="cov6" title="9"> {
                        ptr.Next = node
                }</span>
                <span class="cov6" title="10">ptr = node</span>
        }
        <span class="cov2" title="2">return res</span>
}

func Reduce[T1, T2 any](root *Snode[T1], fnc func(T2, T1) T2, acc T2) T2 <span class="cov2" title="2">{
        for node := root; node != nil; node = node.Next </span><span class="cov6" title="10">{
                acc = fnc(acc, node.Val)
        }</span>
        <span class="cov2" title="2">return acc</span>
}

func ReduceR[T1, T2 any](root *Snode[T1], fnc func(T2, T1) T2, acc T2) T2 <span class="cov7" title="12">{
        if root == nil </span><span class="cov2" title="2">{
                return acc
        }</span>
        <span class="cov6" title="10">return fnc(ReduceR(root.Next, fnc, acc), root.Val)</span>
}

func Filter[T any](root *Snode[T], fnc func(T) bool) *Snode[T] <span class="cov3" title="3">{
        var res, ptr *Snode[T]
        for onode := root; onode != nil; onode = onode.Next </span><span class="cov8" title="20">{
                node := &amp;Snode[T]{Val: onode.Val, Next: nil}
                if fnc(node.Val) </span><span class="cov6" title="10">{
                        if res == nil </span><span class="cov2" title="2">{
                                res = node
                        }</span> else<span class="cov6" title="8"> {
                                ptr.Next = node
                        }</span>
                        <span class="cov6" title="10">ptr = node</span>
                }
        }
        <span class="cov3" title="3">return res</span>
}

func ListSize[T any](root *Snode[T]) int <span class="cov2" title="2">{
        size := 0
        if root == nil </span><span class="cov1" title="1">{
                return size
        }</span>
        <span class="cov1" title="1">for node := root; node != nil; node = node.Next </span><span class="cov6" title="10">{
                size++
        }</span>
        <span class="cov1" title="1">return size</span>
}

func ReverseRec[T any](first *Snode[T]) *Snode[T] <span class="cov8" title="21">{
        if first == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov8" title="20">if first.Next == nil </span><span class="cov2" title="2">{
                return first
        }</span>
        <span class="cov8" title="18">second := first.Next
        root := ReverseRec(second)
        second.Next = first
        first.Next = nil
        return root</span>
}

func Reverse[T any](first *Snode[T]) *Snode[T] <span class="cov5" title="6">{
        var zero, second *Snode[T]
        for first != nil </span><span class="cov10" title="41">{
                second = first.Next
                first.Next = zero
                zero = first
                first = second
        }</span>
        <span class="cov5" title="6">return zero</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package list

import (
        "fmt"
        "sync"
)

const MAXUINT16 int = (1 &lt;&lt; 16)

type HMnode[K comparable, V any] struct {
        Key  K
        Val  V
        Next *HMnode[K, V]
}

type HMap[K comparable, V any] struct {
        keysnum int
        bktsnum int
        rwm     sync.RWMutex
        hmarr   []*HMnode[K, V]
}

func NewHMap[K comparable, V any](buckets ...uint16) *HMap[K, V] <span class="cov1" title="1">{
        bktsnum := 10
        if len(buckets) &gt; 0 &amp;&amp; (buckets[0] &gt; 10) </span><span class="cov0" title="0">{
                bktsnum = int(buckets[0])
        }</span>
        <span class="cov1" title="1">return &amp;HMap[K, V]{
                keysnum: 0,
                bktsnum: bktsnum,
                hmarr:   make([]*HMnode[K, V], bktsnum),
        }</span>
}

func (hm *HMap[K, V]) Buckets() int <span class="cov1" title="1">{
        hm.rwm.RLock()
        defer hm.rwm.RUnlock()

        return hm.bktsnum
}</span>

func (hm *HMap[K, V]) Size() int <span class="cov4" title="8">{
        hm.rwm.RLock()
        defer hm.rwm.RUnlock()

        return hm.keysnum
}</span>

func (hm *HMap[K, V]) IsEmpty() bool <span class="cov3" title="4">{
        return hm.Size() == 0
}</span>

func (hm *HMap[K, V]) convToBytes(key K) []byte <span class="cov8" title="224">{
        return []byte(fmt.Sprintf("%v", key))
}</span>

func (hm *HMap[K, V]) hashDJB2a(data []byte) uint32 <span class="cov8" title="224">{
        var hash uint32 = 5381
        mlen := len(data)
        for i := 0; i &lt; mlen; i++ </span><span class="cov9" title="406">{
                hash = ((hash &lt;&lt; 5) + hash) ^ uint32(data[i])
        }</span>
        <span class="cov8" title="224">return hash</span>
}

func (hm *HMap[K, V]) hashFromKey(key K) int <span class="cov8" title="224">{
        bytesarr := hm.convToBytes(key)
        hash := hm.hashDJB2a(bytesarr)
        return int(hash&amp;0x0000ffff) % hm.bktsnum
}</span>

func (hm *HMap[K, V]) evacuate() <span class="cov1" title="1">{
        newbkts := hm.bktsnum * 5
        switch </span>{ // isSpaceToGrow
        case newbkts &lt; MAXUINT16:<span class="cov1" title="1">
                hm.bktsnum = newbkts</span>
        case newbkts &gt; MAXUINT16:<span class="cov0" title="0">
                hm.bktsnum = MAXUINT16</span>
        default:<span class="cov0" title="0">
                return</span>
        }

        <span class="cov1" title="1">newhmarr := make([]*HMnode[K, V], hm.bktsnum)
        for i, ptr := range hm.hmarr </span><span class="cov4" title="10">{
                if ptr != nil </span><span class="cov4" title="10">{
                        for node, next := ptr, ptr.Next; node != nil; </span><span class="cov7" title="100">{
                                idx := hm.hashFromKey(node.Key)
                                node.Next = newhmarr[idx]
                                newhmarr[idx] = node

                                node = next
                                if next != nil </span><span class="cov7" title="90">{
                                        next = next.Next
                                }</span>
                        }
                        <span class="cov4" title="10">hm.hmarr[i] = nil</span>
                }
        }
        <span class="cov1" title="1">hm.hmarr = newhmarr</span>
}

func (hm *HMap[K, V]) Set(key K, val V) <span class="cov7" title="112">{
        hm.rwm.Lock()
        defer hm.rwm.Unlock()

        newnode := &amp;HMnode[K, V]{Key: key, Val: val, Next: nil}
        hashIDX := hm.hashFromKey(key)
        for node := hm.hmarr[hashIDX]; node != nil; node = node.Next </span><span class="cov10" title="491">{
                if node.Key == key </span><span class="cov4" title="10">{
                        node.Val = val
                        return
                }</span>
        }

        <span class="cov7" title="102">isNeedToGrow := (hm.keysnum &gt;= (hm.bktsnum * 10))
        if isNeedToGrow </span><span class="cov1" title="1">{
                hm.evacuate()
        }</span>

        <span class="cov7" title="102">newnode.Next = hm.hmarr[hashIDX]
        hm.hmarr[hashIDX] = newnode
        hm.keysnum++</span>
}

func (hm *HMap[K, V]) Del(key K) *V <span class="cov2" title="2">{
        hm.rwm.Lock()
        defer hm.rwm.Unlock()

        hashIDX := hm.hashFromKey(key)
        prev := hm.hmarr[hashIDX]
        for node := prev; node != nil; node = node.Next </span><span class="cov1" title="1">{
                if node.Key == key </span><span class="cov1" title="1">{
                        val := &amp;node.Val
                        if prev == hm.hmarr[hashIDX] </span><span class="cov1" title="1">{
                                hm.hmarr[hashIDX] = node.Next
                        }</span> else<span class="cov0" title="0"> {
                                prev.Next = node.Next
                        }</span>
                        <span class="cov1" title="1">hm.keysnum--
                        return val</span>
                }
                <span class="cov0" title="0">prev = node</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (hm *HMap[K, V]) Get(key K) *V <span class="cov4" title="10">{
        hm.rwm.RLock()
        defer hm.rwm.RUnlock()

        hashIDX := hm.hashFromKey(key)
        for node := hm.hmarr[hashIDX]; node != nil; node = node.Next </span><span class="cov3" title="5">{
                if node.Key == key </span><span class="cov3" title="5">{
                        return &amp;node.Val
                }</span>
        }
        <span class="cov3" title="5">return nil</span>
}

func (hm *HMap[K, V]) IterateKeys() []K <span class="cov1" title="1">{
        hm.rwm.RLock()
        defer hm.rwm.RUnlock()

        keysarr := make([]K, 0, hm.keysnum)
        for _, ptr := range hm.hmarr </span><span class="cov4" title="10">{
                for node := ptr; node != nil; node = node.Next </span><span class="cov4" title="8">{
                        keysarr = append(keysarr, node.Key)
                }</span>
        }
        <span class="cov1" title="1">return keysarr</span>
}

func (hm *HMap[K, V]) PrintAll() <span class="cov1" title="1">{
        hm.rwm.RLock()
        defer hm.rwm.RUnlock()

        for idx, ptr := range hm.hmarr </span><span class="cov6" title="50">{
                fmt.Printf("| %d | %p |", idx, ptr)
                for node := ptr; node != nil; node = node.Next </span><span class="cov7" title="101">{
                        fmt.Printf(" -&gt; [key:%v, val:%v, next:%p]", node.Key, node.Val, node.Next)
                }</span>
                <span class="cov6" title="50">fmt.Printf("\n")</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package list

type Snode[T any] struct {
        Val  T
        Next *Snode[T]
}

// ===========================
type Bag[T any] struct {
        first *Snode[T]
        size  int
}

func NewBag[T any]() Bag[T] <span class="cov1" title="1">{
        return Bag[T]{
                first: nil,
                size:  0,
        }
}</span>

func (b *Bag[T]) Size() int <span class="cov7" title="6">{
        return b.size
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov4" title="3">{
        return b.Size() == 0
}</span>

func (b *Bag[T]) Add(val T) <span class="cov7" title="7">{
        b.first = &amp;Snode[T]{Val: val, Next: b.first}
        b.size++
}</span>

func (b *Bag[T]) Iterate() []T <span class="cov3" title="2">{
        res := make([]T, 0, b.size)
        for node := b.first; node != nil; node = node.Next </span><span class="cov10" title="14">{
                res = append(res, node.Val)
        }</span>
        <span class="cov3" title="2">return res</span>
}

func (b *Bag[T]) Reverse() <span class="cov1" title="1">{
        b.first = Reverse(b.first)
}</span>

// ===========================
type Stack[T any] struct {
        first *Snode[T]
        size  int
}

func NewStack[T any]() Stack[T] <span class="cov3" title="2">{
        return Stack[T]{
                first: nil,
                size:  0,
        }
}</span>

func (s *Stack[T]) Size() int <span class="cov8" title="9">{
        return s.size
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov5" title="4">{
        return s.Size() == 0
}</span>

func (s *Stack[T]) Push(val T) <span class="cov10" title="14">{
        s.first = &amp;Snode[T]{Val: val, Next: s.first}
        s.size++
}</span>

func (s *Stack[T]) Pop() T <span class="cov8" title="8">{
        ret := s.first.Val
        s.first = s.first.Next
        s.size--
        return ret
}</span>

func (s *Stack[T]) Iterate() []T <span class="cov1" title="1">{
        res := make([]T, 0, s.size)
        for node := s.first; node != nil; node = node.Next </span><span class="cov7" title="7">{
                res = append(res, node.Val)
        }</span>
        <span class="cov1" title="1">return res</span>
}

func (s *Stack[T]) Reverse() <span class="cov1" title="1">{
        s.first = Reverse(s.first)
}</span>

// ===========================
type Queue[T any] struct {
        first *Snode[T]
        last  *Snode[T]
        size  int
}

func NewQueue[T any]() Queue[T] <span class="cov3" title="2">{
        return Queue[T]{
                first: nil,
                last:  nil,
                size:  0,
        }
}</span>

func (q *Queue[T]) Size() int <span class="cov8" title="9">{
        return q.size
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov5" title="4">{
        return q.Size() == 0
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov10" title="14">{
        newnode := &amp;Snode[T]{Val: val, Next: nil}
        if q.size == 0 </span><span class="cov3" title="2">{
                q.first = newnode
        }</span> else<span class="cov9" title="12"> {
                q.last.Next = newnode
        }</span>
        <span class="cov10" title="14">q.last = newnode
        q.size++</span>
}

func (q *Queue[T]) Deq() T <span class="cov8" title="8">{
        ret := q.first.Val
        q.first = q.first.Next
        q.size--
        if (q.size == 0) || (q.size == 1) </span><span class="cov3" title="2">{
                q.last = q.first
        }</span>
        <span class="cov7" title="7">return ret</span>
}

func (q *Queue[T]) Iterate() []T <span class="cov1" title="1">{
        res := make([]T, 0, q.size)
        for node := q.first; node != nil; node = node.Next </span><span class="cov7" title="7">{
                res = append(res, node.Val)
        }</span>
        <span class="cov1" title="1">return res</span>
}

func (q *Queue[T]) Reverse() <span class="cov1" title="1">{
        q.last = q.first
        q.first = Reverse(q.first)
}</span>

// ===========================
type Dnode[T any] struct {
        Val  T
        Prev *Dnode[T]
        Next *Dnode[T]
}

type Deque[T any] struct {
        first *Dnode[T]
        last  *Dnode[T]
        size  int
}

func NewDeque[T any]() Deque[T] <span class="cov1" title="1">{
        return Deque[T]{
                first: nil,
                last:  nil,
                size:  0,
        }
}</span>

func (d *Deque[T]) Size() int <span class="cov7" title="6">{
        return d.size
}</span>

func (d *Deque[T]) IsEmpty() bool <span class="cov4" title="3">{
        return d.Size() == 0
}</span>

func (d *Deque[T]) Front() T <span class="cov1" title="1">{
        return d.first.Val
}</span>

func (d *Deque[T]) Back() T <span class="cov1" title="1">{
        return d.last.Val
}</span>

func (d *Deque[T]) PushFront(val T) <span class="cov4" title="3">{
        newnode := &amp;Dnode[T]{Val: val, Prev: nil, Next: d.first}
        if d.size == 0 </span><span class="cov1" title="1">{
                d.last = newnode
        }</span> else<span class="cov3" title="2"> {
                d.first.Prev = newnode
        }</span>
        <span class="cov4" title="3">d.first = newnode
        d.size++</span>
}

func (d *Deque[T]) PopFront() T <span class="cov5" title="4">{
        val := d.first.Val
        if d.size == 1 </span><span class="cov0" title="0">{
                d.last = nil
                d.first = nil
        }</span> else<span class="cov4" title="3"> {
                d.first = d.first.Next
                d.first.Prev = nil
        }</span>
        <span class="cov4" title="3">d.size--
        return val</span>
}

func (d *Deque[T]) PushBack(val T) <span class="cov4" title="3">{
        newnode := &amp;Dnode[T]{Val: val, Prev: d.last, Next: nil}
        if d.size == 0 </span><span class="cov0" title="0">{
                d.first = newnode
        }</span> else<span class="cov4" title="3"> {
                d.last.Next = newnode
        }</span>
        <span class="cov4" title="3">d.last = newnode
        d.size++</span>
}

func (d *Deque[T]) PopBack() T <span class="cov5" title="4">{
        val := d.last.Val
        if d.size == 1 </span><span class="cov1" title="1">{
                d.last = nil
                d.first = nil
        }</span> else<span class="cov3" title="2"> {
                d.last = d.last.Prev
                d.last.Next = nil
        }</span>
        <span class="cov4" title="3">d.size--
        return val</span>
}

func (d *Deque[T]) Iterate() []T <span class="cov3" title="2">{
        res := make([]T, 0, d.size)
        for node := d.first; node != nil; node = node.Next </span><span class="cov9" title="12">{
                res = append(res, node.Val)
        }</span>
        <span class="cov3" title="2">return res</span>
}

func (d *Deque[T]) Reverse() <span class="cov1" title="1">{
        d.first, d.last = d.last, d.first
        for node := d.first; node != nil; node = node.Next </span><span class="cov7" title="6">{
                node.Next, node.Prev = node.Prev, node.Next
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package sync

import (
        "errors"
        "sync"
        "time"

        I "github.com/kselnaag/algos/types"
)

// ====================
type Future[F any] struct {
        val  I.Result[F]
        ch   chan I.Result[F]
        once *sync.Once
        cpl  bool
}

func NewFuture[F any](fn func() I.Result[F]) Future[F] <span class="cov7" title="5">{
        future := Future[F]{
                val:  I.NewResultError[F](errors.New("algos.types.(Future): callback is timed out")),
                ch:   make(chan I.Result[F]),
                once: new(sync.Once),
                cpl:  false,
        }
        go func() </span><span class="cov7" title="5">{
                future.ch &lt;- fn()
        }</span>()
        <span class="cov7" title="5">return future</span>
}

func (fut *Future[F]) IsCompleted() bool <span class="cov10" title="10">{
        if len(fut.ch) &gt; 0 </span><span class="cov0" title="0">{
                fut.cpl = true
        }</span>
        <span class="cov10" title="10">return fut.cpl</span>
}

func (fut *Future[F]) Value() I.Result[F] <span class="cov8" title="6">{ // Lock until result
        fut.once.Do(func() </span><span class="cov5" title="3">{
                fut.val = &lt;-fut.ch
                fut.cpl = true
        }</span>)
        <span class="cov8" title="6">return fut.val</span>
}

func (fut *Future[F]) OnComplete(fn func(I.Result[F])) <span class="cov5" title="3">{
        go func() </span><span class="cov5" title="3">{
                fn(fut.Value())
        }</span>()
}

func (fut *Future[F]) ToString() string <span class="cov7" title="5">{
        return fut.val.ToString()
}</span>

// ====================
type Promise[P any] struct {
        Future[P]
        timeout time.Duration
}

func NewPromise[P any](ms int, fn func() I.Result[P]) Promise[P] <span class="cov3" title="2">{
        return Promise[P]{
                Future:  NewFuture(fn),
                timeout: time.Duration(ms) * time.Millisecond,
        }
}</span>

func (pro *Promise[P]) Value() I.Result[P] <span class="cov6" title="4">{
        pro.once.Do(func() </span><span class="cov3" title="2">{
        label:
                for </span><span class="cov3" title="2">{
                        select </span>{
                        case pro.val = &lt;-pro.ch:<span class="cov1" title="1">
                                break label</span>
                        case &lt;-time.After(pro.timeout):<span class="cov1" title="1">
                                break label</span>
                        }
                }
                <span class="cov3" title="2">pro.cpl = true</span>
        })
        <span class="cov6" title="4">return pro.val</span>
}

func (pro *Promise[P]) OnComplete(fn func(I.Result[P])) <span class="cov3" title="2">{
        go func() </span><span class="cov3" title="2">{
                fn(pro.Value())
        }</span>()
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package tree

import (
        "fmt"

        "github.com/kselnaag/algos/amath"
        I "github.com/kselnaag/algos/types"
)

// right-linear Arne Andersson tree with intensive node deletion
type AAnode[K I.Ord, V any] struct {
        Key  K
        Val  V
        L, R *AAnode[K, V]
        Lvl  byte
}

type AAmap[K I.Ord, V any] struct {
        root *AAnode[K, V]
        size int
}

func NewAAmap[K I.Ord, V any]() AAmap[K, V] <span class="cov1" title="1">{
        return AAmap[K, V]{
                root: nil,
                size: 0,
        }
}</span>

func (tm *AAmap[K, V]) Size() int <span class="cov5" title="10">{
        return tm.size
}</span>

func (tm *AAmap[K, V]) IsEmpty() bool <span class="cov3" title="4">{
        return tm.Size() == 0
}</span>

func (tm *AAmap[K, V]) IsKey(key K) bool <span class="cov5" title="11">{
        node := tm.root
        for node != nil </span><span class="cov7" title="33">{
                switch </span>{
                case I.LT(key, node.Key):<span class="cov5" title="10">
                        node = node.L</span>
                case I.GT(key, node.Key):<span class="cov5" title="13">
                        node = node.R</span>
                default:<span class="cov5" title="10">
                        return true</span>
                }
        }
        <span class="cov1" title="1">return false</span>
}

func (tm *AAmap[K, V]) Get(key K) V <span class="cov5" title="12">{
        node := tm.root
        for node != nil </span><span class="cov7" title="37">{
                switch </span>{
                case I.LT(key, node.Key):<span class="cov5" title="12">
                        node = node.L</span>
                case I.GT(key, node.Key):<span class="cov5" title="15">
                        node = node.R</span>
                default:<span class="cov5" title="10">
                        return node.Val</span>
                }
        }
        <span class="cov2" title="2">panic("algos.tree.(AAmap).Get(key): No any key found, check first")</span>
}

func (tm *AAmap[K, V]) Put(key K, val V) <span class="cov5" title="14">{
        tm.root = tm.put(tm.root, key, val)
}</span>

func (tm *AAmap[K, V]) put(node *AAnode[K, V], key K, val V) *AAnode[K, V] <span class="cov7" title="40">{
        if node == nil </span><span class="cov5" title="11">{
                tm.size++
                node = &amp;AAnode[K, V]{Key: key, Val: val, L: nil, R: nil, Lvl: 1}
        }</span> else<span class="cov7" title="29"> {
                switch </span>{
                case I.LT(key, node.Key):<span class="cov5" title="11">
                        node.L = tm.put(node.L, key, val)</span>
                case I.GT(key, node.Key):<span class="cov5" title="15">
                        node.R = tm.put(node.R, key, val)</span>
                default:<span class="cov3" title="3">
                        node.Val = val</span>
                }
        }
        <span class="cov7" title="40">return tm.balance(node)</span>
}

func (tm *AAmap[K, V]) balance(node *AAnode[K, V]) *AAnode[K, V] <span class="cov7" title="40">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov7" title="40">node = tm.skew(node)
        node = tm.split(node)
        return node</span>
}

func (tm *AAmap[K, V]) skew(node *AAnode[K, V]) *AAnode[K, V] <span class="cov8" title="60">{ // rightRotation
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="60">if (node.L != nil) &amp;&amp; (node.L.Lvl == node.Lvl) </span><span class="cov4" title="6">{
                x := node.L
                node.L = x.R
                x.R = node
                return x
        }</span>
        <span class="cov8" title="54">return node</span>
}

func (tm *AAmap[K, V]) split(node *AAnode[K, V]) *AAnode[K, V] <span class="cov8" title="55">{ // leftRotation
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="55">if (node.R != nil) &amp;&amp; (node.R.R != nil) &amp;&amp; (node.Lvl == node.R.R.Lvl) </span><span class="cov3" title="4">{
                x := node.R
                node.R = x.L
                x.L = node
                x.Lvl++
                return x
        }</span>
        <span class="cov8" title="51">return node</span>
}

func (tm *AAmap[K, V]) Del(key K) <span class="cov4" title="7">{
        tm.root = tm.del(tm.root, key)
}</span>

func (tm *AAmap[K, V]) del(node *AAnode[K, V], key K) *AAnode[K, V] <span class="cov5" title="14">{
        if node == nil </span><span class="cov2" title="2">{
                panic("algos.tree.(AAmap).Del(key): No any key found, check first")</span>
        }
        <span class="cov5" title="12">switch </span>{
        case I.LT(key, node.Key):<span class="cov1" title="1">
                node.L = tm.del(node.L, key)</span>
        case I.GT(key, node.Key):<span class="cov4" title="6">
                node.R = tm.del(node.R, key)</span>
        default:<span class="cov3" title="5">
                if tm.size &gt; 0 </span><span class="cov3" title="5">{
                        tm.size--
                }</span>
                <span class="cov3" title="5">if node.R == nil </span><span class="cov1" title="1">{
                        return node.L
                }</span>
                <span class="cov3" title="4">min := tm.min(node.R)
                node.Key = min.Key
                node.Val = min.Val
                node.R = tm.delmin(node.R)</span>
        }
        <span class="cov4" title="8">return tm.balanceDel(node)</span>
}

func (tm *AAmap[K, V]) min(node *AAnode[K, V]) *AAnode[K, V] <span class="cov4" title="6">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="6">if node.L == nil </span><span class="cov3" title="4">{
                return node
        }</span>
        <span class="cov2" title="2">return tm.min(node.L)</span>
}

func (tm *AAmap[K, V]) delmin(node *AAnode[K, V]) *AAnode[K, V] <span class="cov4" title="6">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="6">if node.L == nil </span><span class="cov3" title="4">{
                return node.R
        }</span>
        <span class="cov2" title="2">node.L = tm.delmin(node.L)
        return node</span>
}

func (tm *AAmap[K, V]) balanceDel(node *AAnode[K, V]) *AAnode[K, V] <span class="cov4" title="8">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="8">node = tm.decrLvl(node)
        node = tm.skew(node)
        if node.R != nil </span><span class="cov4" title="7">{
                node.R = tm.skew(node.R)
        }</span>
        <span class="cov4" title="8">if (node.R != nil) &amp;&amp; (node.R.R != nil) </span><span class="cov3" title="5">{
                node.R.R = tm.skew(node.R.R)
        }</span>
        <span class="cov4" title="8">node = tm.split(node)
        if node.R != nil </span><span class="cov4" title="7">{
                node.R = tm.split(node.R)
        }</span>
        <span class="cov4" title="8">return node</span>
}

func (tm *AAmap[K, V]) decrLvl(node *AAnode[K, V]) *AAnode[K, V] <span class="cov4" title="8">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="8">lvl := byte(1)
        if (node.L != nil) &amp;&amp; (node.R != nil) </span><span class="cov4" title="6">{
                lvl = amath.Min(node.L.Lvl, node.R.Lvl) + 1
        }</span>
        <span class="cov4" title="8">if lvl &lt; node.Lvl </span><span class="cov2" title="2">{
                node.Lvl = lvl
                if (node.R != nil) &amp;&amp; (lvl &lt; node.R.Lvl) </span><span class="cov0" title="0">{
                        node.R.Lvl = lvl
                }</span>
        }
        <span class="cov4" title="8">return node</span>
}

func (tm *AAmap[K, V]) IterateKeys() []K <span class="cov2" title="2">{
        keysarr := make([]K, 0, tm.Size())
        return tm.iteratekeys(tm.root, keysarr)
}</span>

func (tm *AAmap[K, V]) iteratekeys(node *AAnode[K, V], keysarr []K) []K <span class="cov7" title="34">{
        if node == nil </span><span class="cov6" title="18">{
                return keysarr
        }</span>
        <span class="cov6" title="16">keysarr = tm.iteratekeys(node.L, keysarr)
        keysarr = append(keysarr, node.Key)
        keysarr = tm.iteratekeys(node.R, keysarr)
        return keysarr</span>
}

func (tm *AAmap[K, V]) PrintTreeCheck() <span class="cov2" title="2">{
        fmt.Printf("\n")
        fmt.Printf("&lt;- left rotated tree pic &lt;-\n")
        tm.printtree(tm.root, 0)
        fmt.Printf("=============================\n\n")
}</span>

func (tm *AAmap[K, V]) printtree(node *AAnode[K, V], n int) <span class="cov7" title="34">{
        if node != nil </span><span class="cov6" title="16">{
                tm.printtree(node.R, n+5)
                for i := 0; i &lt; n; i++ </span><span class="cov10" title="140">{
                        fmt.Printf(" ")
                }</span>
                <span class="cov6" title="16">fmt.Printf("%v^%v:%v\n", node.Lvl, node.Key, node.Val)
                tm.printtree(node.L, n+5)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package tree

import (
        "fmt"
        "math"

        I "github.com/kselnaag/algos/types"
)

// tree based Priority Queue
type PQnode[K I.Ord, V any] struct {
        Key     K
        Val     V
        P, L, R *PQnode[K, V]
}

// ===========================
type MinPQ[K I.Ord, V any] struct {
        root *PQnode[K, V]
        size int
}

func NewMinPQ[K I.Ord, V any]() MinPQ[K, V] <span class="cov0" title="0">{
        return MinPQ[K, V]{
                root: nil,
                size: 0,
        }
}</span>

func (min *MinPQ[K, V]) Size() int <span class="cov0" title="0">{
        return min.size
}</span>

func (min *MinPQ[K, V]) IsEmpty() bool <span class="cov0" title="0">{
        return min.Size() == 0
}</span>

func (min *MinPQ[K, V]) Add(key K, val V) <span class="cov0" title="0">{
        if min.IsEmpty() </span><span class="cov0" title="0">{
                min.root = &amp;PQnode[K, V]{Key: key, Val: val, P: nil, L: nil, R: nil}
                min.root.P = min.root
        }</span> else<span class="cov0" title="0"> {
                nodePar := min.lastRightNodePar(min.root.P)
                node := &amp;PQnode[K, V]{Key: key, Val: val, P: nodePar, L: nil, R: nil}
                if nodePar.L == nil </span><span class="cov0" title="0">{
                        nodePar.L = node
                }</span> else<span class="cov0" title="0"> {
                        nodePar.R = node
                }</span>
                <span class="cov0" title="0">min.root.P = node
                min.swimNode(node)</span>
        }
        <span class="cov0" title="0">min.size++</span>
}

func (min *MinPQ[K, V]) lastRightNodePar(lastnode *PQnode[K, V]) *PQnode[K, V] <span class="cov0" title="0">{
        if lastnode == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if lastnode == min.root </span><span class="cov0" title="0">{
                return min.root
        }</span>
        <span class="cov0" title="0">node := lastnode.P
        if lastnode == node.R </span><span class="cov0" title="0">{
                for (node != min.root) &amp;&amp; (lastnode == node.R) </span><span class="cov0" title="0">{
                        lastnode = node
                        node = node.P
                }</span>
                <span class="cov0" title="0">if lastnode != node.R </span><span class="cov0" title="0">{
                        node = node.R
                }</span>
                <span class="cov0" title="0">for node.L != nil </span><span class="cov0" title="0">{
                        node = node.L
                }</span>
        }
        <span class="cov0" title="0">return node</span>
}

func (min *MinPQ[K, V]) swapNode(i, j *PQnode[K, V]) <span class="cov0" title="0">{
        i.Key, i.Val, j.Key, j.Val = j.Key, j.Val, i.Key, i.Val
}</span>

func (min *MinPQ[K, V]) swimNode(node *PQnode[K, V]) <span class="cov0" title="0">{
        if (node == nil) || (node.P == nil) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for (node != min.root) &amp;&amp; I.LT(node.Key, node.P.Key) </span><span class="cov0" title="0">{
                min.swapNode(node, node.P)
                node = node.P
        }</span>
}

func (min *MinPQ[K, V]) Min() (key K, val V) <span class="cov0" title="0">{
        return min.root.Key, min.root.Val
}</span>

func (min *MinPQ[K, V]) DelMin() (key K, val V) <span class="cov0" title="0">{
        if min.IsEmpty() </span><span class="cov0" title="0">{
                panic("algos.tree.(MinPQ).DelMin(): No any node found, tree is empty")</span>
        }
        <span class="cov0" title="0">key, val = min.root.Key, min.root.Val
        if min.size == 1 </span><span class="cov0" title="0">{
                min.root = nil
                min.size--
                return key, val
        }</span>
        <span class="cov0" title="0">node := min.lastLeftNode(min.root.P)
        min.swapNode(min.root.P, min.root)
        if min.root.P.P.R == nil </span><span class="cov0" title="0">{
                min.root.P.P.L = nil
        }</span> else<span class="cov0" title="0"> {
                min.root.P.P.R = nil
        }</span>
        <span class="cov0" title="0">min.root.P = node
        min.sinkNode(min.root)
        min.size--
        return key, val</span>
}

func (min *MinPQ[K, V]) lastLeftNode(lastnode *PQnode[K, V]) *PQnode[K, V] <span class="cov0" title="0">{
        if lastnode == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if lastnode == min.root </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">node := lastnode.P
        if lastnode != node.L </span><span class="cov0" title="0">{
                return node.L
        }</span> else<span class="cov0" title="0"> {
                for (node != min.root) &amp;&amp; (lastnode == node.L) </span><span class="cov0" title="0">{
                        lastnode = node
                        node = node.P
                }</span>
                <span class="cov0" title="0">if lastnode != node.L </span><span class="cov0" title="0">{
                        node = node.L
                }</span>
                <span class="cov0" title="0">for node.R != nil </span><span class="cov0" title="0">{
                        node = node.R
                }</span>
        }
        <span class="cov0" title="0">return node</span>
}

func (min *MinPQ[K, V]) sinkNode(node *PQnode[K, V]) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if (node == nil) || ((node.L == nil) &amp;&amp; (node.R == nil)) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if (node.R == nil) &amp;&amp; (node.L != nil) &amp;&amp; I.GT(node.Key, node.L.Key) </span><span class="cov0" title="0">{
                        min.swapNode(node, node.L)
                        node = node.L
                        continue</span>
                }
                <span class="cov0" title="0">if (node.L == nil) &amp;&amp; (node.R != nil) &amp;&amp; I.GT(node.Key, node.R.Key) </span><span class="cov0" title="0">{
                        min.swapNode(node, node.R)
                        node = node.R
                        continue</span>
                }
                <span class="cov0" title="0">if I.GT(node.L.Key, node.R.Key) </span><span class="cov0" title="0">{
                        min.swapNode(node.L, node.R)
                }</span>
                <span class="cov0" title="0">if I.GT(node.Key, node.L.Key) </span><span class="cov0" title="0">{
                        min.swapNode(node, node.L)
                        node = node.L
                        continue</span>
                } else<span class="cov0" title="0"> if I.GT(node.Key, node.R.Key) </span><span class="cov0" title="0">{
                        min.swapNode(node, node.R)
                        node = node.R
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }
}

func (min *MinPQ[K, V]) Iterate() []K <span class="cov0" title="0">{
        keysarr := make([]K, 0, min.Size())
        return min.iterate(min.root, keysarr)
}</span>

func (min *MinPQ[K, V]) iterate(node *PQnode[K, V], keysarr []K) []K <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return keysarr
        }</span>
        <span class="cov0" title="0">keysarr = append(keysarr, node.Key)
        keysarr = min.iterate(node.L, keysarr)
        keysarr = min.iterate(node.R, keysarr)
        return keysarr</span>
}

func (min *MinPQ[K, V]) HeightTreeCheck() int <span class="cov0" title="0">{
        if min.IsEmpty() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">sqrt := math.Sqrt(float64(min.size))
        return int(math.Ceil(sqrt))</span>
}

func (min *MinPQ[K, V]) IsCompleteBTcheck() bool <span class="cov0" title="0">{
        return min.iscompleteBTcheck(min.root, min.Size())
}</span>

func (min *MinPQ[K, V]) iscompleteBTcheck(node *PQnode[K, V], size int) bool <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">sqrt := math.Sqrt(float64(size))
        CBTlvl := math.Ceil(sqrt)
        maxCBTsize := int(math.Pow(2, CBTlvl))
        arr := make([]*PQnode[K, V], maxCBTsize)
        arr[1] = node
        for i := 1; i &lt; maxCBTsize; i++ </span><span class="cov0" title="0">{
                if arr[i].L != nil </span><span class="cov0" title="0">{
                        arr[2*i] = arr[i].L
                }</span>
                <span class="cov0" title="0">if arr[i].R != nil </span><span class="cov0" title="0">{
                        arr[2*i+1] = arr[i].R
                }</span>
        }
        <span class="cov0" title="0">for i := 1; i &lt;= size; i++ </span><span class="cov0" title="0">{
                if arr[i] == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (min *MinPQ[K, V]) PrintTreeCheck() <span class="cov0" title="0">{
        fmt.Printf("\n")
        fmt.Printf("&lt;- left rotated tree pic &lt;-\n")
        min.printtree(min.root, 0)
        fmt.Printf("=============================\n\n")
}</span>

func (min *MinPQ[K, V]) printtree(node *PQnode[K, V], n int) <span class="cov0" title="0">{
        if node != nil </span><span class="cov0" title="0">{
                min.printtree(node.R, n+5)
                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        fmt.Printf(" ")
                }</span>
                <span class="cov0" title="0">fmt.Printf("%v:%v\n", node.Key, node.Val)
                min.printtree(node.L, n+5)</span>
        }
}

/*
NewMinPQ Size IsEmpty HeightTree Add swimNode swapNode
Min DelMin sinkNode Iterate iterate
lastRightNodePar lastLeftNode

CompleteBTCheck HeightTreeCheck PrintTreeCheck printtree
*/

// ===========================
</pre>
		
		<pre class="file" id="file14" style="display: none">package tree

import (
        "fmt"

        "github.com/kselnaag/algos/amath"
        I "github.com/kselnaag/algos/types"
)

// left-linear red-black tree with lazy node deletion
type RBnode[K I.Ord, V any] struct {
        Key          K
        Val          V
        L, R         *RBnode[K, V]
        IsRed, IsDel bool
}

type RBmap[K I.Ord, V any] struct {
        root *RBnode[K, V]
        size int
}

func NewRBmap[K I.Ord, V any]() RBmap[K, V] <span class="cov1" title="1">{
        return RBmap[K, V]{
                root: nil,
                size: 0,
        }
}</span>

func (tm *RBmap[K, V]) Size() int <span class="cov7" title="30">{
        return tm.size
}</span>

func (tm *RBmap[K, V]) IsEmpty() bool <span class="cov7" title="24">{
        return tm.Size() == 0
}</span>

func (tm *RBmap[K, V]) IsKey(key K) bool <span class="cov5" title="11">{
        node := tm.root
        for node != nil </span><span class="cov7" title="33">{
                switch </span>{
                case I.LT(key, node.Key):<span class="cov6" title="13">
                        node = node.L</span>
                case I.GT(key, node.Key):<span class="cov5" title="10">
                        node = node.R</span>
                default:<span class="cov5" title="10">
                        return !node.IsDel</span>
                }
        }
        <span class="cov1" title="1">return false</span>
}

func (tm *RBmap[K, V]) Get(key K) V <span class="cov5" title="12">{
        node := tm.root
        for node != nil </span><span class="cov8" title="36">{
                switch </span>{
                case I.LT(key, node.Key):<span class="cov6" title="13">
                        node = node.L</span>
                case I.GT(key, node.Key):<span class="cov5" title="12">
                        node = node.R</span>
                default:<span class="cov5" title="11">
                        if !node.IsDel </span><span class="cov5" title="10">{
                                return node.Val
                        }</span>
                        <span class="cov1" title="1">node = nil</span>
                }
        }
        <span class="cov2" title="2">panic("algos.tree.(RBmap).Get(key): No any key found, check first")</span>
}

func (tm *RBmap[K, V]) Del(key K) <span class="cov4" title="6">{
        if tm.IsEmpty() </span><span class="cov1" title="1">{
                panic("algos.tree.(RBmap).Del(): No any key found, tree is empty")</span>
        }
        <span class="cov4" title="5">node := tm.root
        for node != nil </span><span class="cov6" title="15">{
                switch </span>{
                case I.LT(key, node.Key):<span class="cov2" title="2">
                        node = node.L</span>
                case I.GT(key, node.Key):<span class="cov5" title="9">
                        node = node.R</span>
                default:<span class="cov3" title="4">
                        node.IsDel = true
                        if tm.size &gt; 0 </span><span class="cov3" title="4">{
                                tm.size--
                        }</span>
                        <span class="cov3" title="4">return</span>
                }
        }
        <span class="cov1" title="1">panic("algos.tree.(RBmap).Del(key): No any key found, check first")</span>
}

func (tm *RBmap[K, V]) Put(key K, val V) <span class="cov6" title="14">{
        tm.root = tm.put(tm.root, key, val)
        if !tm.IsEmpty() </span><span class="cov6" title="14">{
                tm.root.IsRed = false
        }</span>
}

func (tm *RBmap[K, V]) put(node *RBnode[K, V], key K, val V) *RBnode[K, V] <span class="cov8" title="42">{
        if node == nil </span><span class="cov5" title="10">{
                tm.size++
                node = &amp;RBnode[K, V]{Key: key, Val: val, L: nil, R: nil, IsRed: true, IsDel: false}
        }</span> else<span class="cov7" title="32"> {
                switch </span>{
                case I.LT(key, node.Key):<span class="cov6" title="16">
                        node.L = tm.put(node.L, key, val)</span>
                case I.GT(key, node.Key):<span class="cov5" title="12">
                        node.R = tm.put(node.R, key, val)</span>
                default:<span class="cov3" title="4">
                        node.Val = val
                        if node.IsDel </span><span class="cov1" title="1">{
                                node.IsDel = false
                                tm.size++
                        }</span>
                }
        }
        <span class="cov8" title="42">return tm.balance(node)</span>
}

func (tm *RBmap[K, V]) balance(node *RBnode[K, V]) *RBnode[K, V] <span class="cov8" title="42">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="42">if (node.L == nil || !node.L.IsRed) &amp;&amp; (node.R != nil) &amp;&amp; node.R.IsRed </span><span class="cov4" title="6">{
                node = tm.rotateLeft(node)
        }</span>
        <span class="cov8" title="42">if (node.L != nil) &amp;&amp; node.L.IsRed &amp;&amp; (node.L.L != nil) &amp;&amp; node.L.L.IsRed </span><span class="cov3" title="3">{
                node = tm.rotateRight(node)
        }</span>
        <span class="cov8" title="42">if (node.L != nil) &amp;&amp; node.L.IsRed &amp;&amp; (node.R != nil) &amp;&amp; node.R.IsRed </span><span class="cov3" title="4">{
                tm.flipColors(node)
        }</span>
        <span class="cov8" title="42">return node</span>
}

func (tm *RBmap[K, V]) rotateLeft(node *RBnode[K, V]) *RBnode[K, V] <span class="cov4" title="6">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="6">x := node.R
        node.R = x.L
        x.L = node
        x.IsRed = node.IsRed
        node.IsRed = true
        return x</span>
}

func (tm *RBmap[K, V]) rotateRight(node *RBnode[K, V]) *RBnode[K, V] <span class="cov3" title="3">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="3">x := node.L
        node.L = x.R
        x.R = node
        x.IsRed = node.IsRed
        node.IsRed = true
        return x</span>
}

func (tm *RBmap[K, V]) flipColors(node *RBnode[K, V]) <span class="cov3" title="4">{
        if node != nil </span><span class="cov3" title="4">{
                node.IsRed = true
                if node.L != nil </span><span class="cov3" title="4">{
                        node.L.IsRed = false
                }</span>
                <span class="cov3" title="4">if node.R != nil </span><span class="cov3" title="4">{
                        node.R.IsRed = false
                }</span>
        }
}

func (tm *RBmap[K, V]) IterateKeys() []K <span class="cov2" title="2">{
        keysarr := make([]K, 0, tm.Size())
        return tm.iteratekeys(tm.root, keysarr)
}</span>

func (tm *RBmap[K, V]) iteratekeys(node *RBnode[K, V], keysarr []K) []K <span class="cov8" title="42">{
        if node == nil </span><span class="cov7" title="22">{
                return keysarr
        }</span>
        <span class="cov6" title="20">keysarr = tm.iteratekeys(node.L, keysarr)
        if !node.IsDel </span><span class="cov6" title="17">{
                keysarr = append(keysarr, node.Key)
        }</span>
        <span class="cov6" title="20">keysarr = tm.iteratekeys(node.R, keysarr)
        return keysarr</span>
}

func (tm *RBmap[K, V]) IsBSTcheck() bool <span class="cov2" title="2">{
        return tm.isbst(tm.root, nil, nil)
}</span>

func (tm *RBmap[K, V]) isbst(node *RBnode[K, V], min, max *K) bool <span class="cov8" title="42">{
        if node == nil </span><span class="cov7" title="22">{
                return true
        }</span>
        <span class="cov6" title="20">if (min != nil) &amp;&amp; (node.Key &lt;= *min) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov6" title="20">if (max != nil) &amp;&amp; (node.Key &gt;= *max) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov6" title="20">return tm.isbst(node.L, min, &amp;node.Key) &amp;&amp; tm.isbst(node.R, &amp;node.Key, max)</span>
}

func (tm *RBmap[K, V]) BSTheightCheck() int <span class="cov2" title="2">{
        return tm.bstheight(tm.root)
}</span>

func (tm *RBmap[K, V]) bstheight(node *RBnode[K, V]) int <span class="cov8" title="42">{
        if node == nil </span><span class="cov7" title="22">{
                return -1
        }</span>
        <span class="cov6" title="20">return 1 + amath.Max(tm.bstheight(node.L), tm.bstheight(node.R))</span>
}

func (tm *RBmap[K, V]) IsRedBlackCheck() bool <span class="cov2" title="2">{
        return tm.isredblack(tm.root)
}</span>

func (tm *RBmap[K, V]) isredblack(node *RBnode[K, V]) bool <span class="cov8" title="42">{
        if node == nil </span><span class="cov7" title="22">{
                return true
        }</span>
        <span class="cov6" title="20">if (node.R != nil) &amp;&amp; node.R.IsRed </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov6" title="20">if (node != tm.root) &amp;&amp; node.IsRed &amp;&amp; (node.L != nil) &amp;&amp; node.L.IsRed </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov6" title="20">return tm.isredblack(node.L) &amp;&amp; tm.isredblack(node.R)</span>
}

func (tm *RBmap[K, V]) IsBalancedCheck() bool <span class="cov2" title="2">{
        blacknum := 0
        node := tm.root
        for node != nil </span><span class="cov5" title="8">{
                if !node.IsRed </span><span class="cov4" title="6">{
                        blacknum++
                }</span>
                <span class="cov5" title="8">node = node.L</span>
        }
        <span class="cov2" title="2">return tm.isbalanced(tm.root, blacknum)</span>
}

func (tm *RBmap[K, V]) isbalanced(node *RBnode[K, V], blacknum int) bool <span class="cov8" title="42">{
        if node == nil </span><span class="cov7" title="22">{
                return blacknum == 0
        }</span>
        <span class="cov6" title="20">if !node.IsRed </span><span class="cov6" title="14">{
                blacknum--
        }</span>
        <span class="cov6" title="20">return tm.isbalanced(node.L, blacknum) &amp;&amp; tm.isbalanced(node.R, blacknum)</span>
}

func (tm *RBmap[K, V]) PrintTreeCheck() <span class="cov1" title="1">{
        fmt.Printf("\n")
        fmt.Printf("&lt;- left rotated tree pic &lt;-\n")
        tm.printtree(tm.root, 0)
        fmt.Printf("(+ Red node, x Del node, * Red and Del node )\n\n")
}</span>

func (tm *RBmap[K, V]) printtree(node *RBnode[K, V], n int) <span class="cov7" title="21">{
        if node != nil </span><span class="cov5" title="10">{
                tm.printtree(node.R, n+5)
                for i := 0; i &lt; n; i++ </span><span class="cov10" title="95">{
                        fmt.Printf(" ")
                }</span>
                <span class="cov5" title="10">if node.IsRed &amp;&amp; node.IsDel </span><span class="cov1" title="1">{
                        fmt.Printf("*")
                }</span> else<span class="cov5" title="9"> {
                        if node.IsRed </span><span class="cov2" title="2">{
                                fmt.Printf("+")
                        }</span>
                        <span class="cov5" title="9">if node.IsDel </span><span class="cov2" title="2">{
                                fmt.Printf("x")
                        }</span>
                }
                <span class="cov5" title="10">fmt.Printf("%v:%v\n", node.Key, node.Val)
                tm.printtree(node.L, n+5)</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package types

import "fmt"

type TestStruct struct {
        A int
        B int
}

func (s TestStruct) CompareTo(obj STOrd) int <span class="cov7" title="6">{
        objComp, ok := obj.(*TestStruct)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("algos.types.TestStruct.CompareTo(obj STOrd): "+
                        "Type of arg is unknown, expected *types.TestStruct, actual %T", obj))</span>
        }
        <span class="cov7" title="6">compFactor := func(st TestStruct) int </span><span class="cov10" title="12">{
                return st.A + st.B
        }</span>
        <span class="cov7" title="6">this := compFactor(s)
        that := compFactor(*objComp)
        switch </span>{
        case this &lt; that:<span class="cov4" title="3">
                return -1</span>
        case this &gt; that:<span class="cov3" title="2">
                return +1</span>
        default:<span class="cov1" title="1">
                return 0</span>
        }
}

func ConvToByteArr(key any) []byte <span class="cov6" title="4">{
        return []byte(fmt.Sprintf("%v", key))
}</span>

func LT[T any](i, j T) bool <span class="cov10" title="12">{
        switch ii := any(i).(type) </span>{
        case STOrd:<span class="cov3" title="2">
                jj, ok := any(j).(STOrd)
                if ok </span><span class="cov3" title="2">{
                        return ii.CompareTo(jj) &lt; 0
                }</span>
        case int:<span class="cov3" title="2">
                jj, ok := any(j).(int)
                if ok </span><span class="cov3" title="2">{
                        return ii &lt; jj
                }</span>
        case int8:<span class="cov0" title="0">
                jj, ok := any(j).(int8)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        case int16:<span class="cov0" title="0">
                jj, ok := any(j).(int16)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        case int32:<span class="cov0" title="0">
                jj, ok := any(j).(int32)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        case int64:<span class="cov0" title="0">
                jj, ok := any(j).(int64)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        case float32:<span class="cov0" title="0">
                jj, ok := any(j).(float32)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        case float64:<span class="cov3" title="2">
                jj, ok := any(j).(float64)
                if ok </span><span class="cov3" title="2">{
                        return ii &lt; jj
                }</span>
        case string:<span class="cov3" title="2">
                jj, ok := any(j).(string)
                if ok </span><span class="cov3" title="2">{
                        return ii &lt; jj
                }</span>
        case uint:<span class="cov3" title="2">
                jj, ok := any(j).(uint)
                if ok </span><span class="cov3" title="2">{
                        return ii &lt; jj
                }</span>
        case uint8:<span class="cov0" title="0">
                jj, ok := any(j).(uint8)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        case uint16:<span class="cov0" title="0">
                jj, ok := any(j).(uint16)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        case uint32:<span class="cov3" title="2">
                jj, ok := any(j).(uint32)
                if ok </span><span class="cov3" title="2">{
                        return ii &lt; jj
                }</span>
        case uint64:<span class="cov0" title="0">
                jj, ok := any(j).(uint64)
                if ok </span><span class="cov0" title="0">{
                        return ii &lt; jj
                }</span>
        }
        <span class="cov0" title="0">panic(fmt.Sprintf("algos.types.LT[T any](i, j T): "+
                "Type of args is not processed: arg Type is %T", i))</span>
}

func GT[T any](i, j T) bool <span class="cov10" title="12">{
        switch ii := any(i).(type) </span>{
        case STOrd:<span class="cov3" title="2">
                jj, ok := any(j).(STOrd)
                if ok </span><span class="cov3" title="2">{
                        return ii.CompareTo(jj) &gt; 0
                }</span>
        case int:<span class="cov3" title="2">
                jj, ok := any(j).(int)
                if ok </span><span class="cov3" title="2">{
                        return ii &gt; jj
                }</span>
        case int8:<span class="cov0" title="0">
                jj, ok := any(j).(int8)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        case int16:<span class="cov0" title="0">
                jj, ok := any(j).(int16)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        case int32:<span class="cov0" title="0">
                jj, ok := any(j).(int32)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        case int64:<span class="cov0" title="0">
                jj, ok := any(j).(int64)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        case float32:<span class="cov0" title="0">
                jj, ok := any(j).(float32)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        case float64:<span class="cov3" title="2">
                jj, ok := any(j).(float64)
                if ok </span><span class="cov3" title="2">{
                        return ii &gt; jj
                }</span>
        case string:<span class="cov3" title="2">
                jj, ok := any(j).(string)
                if ok </span><span class="cov3" title="2">{
                        return ii &gt; jj
                }</span>
        case uint:<span class="cov3" title="2">
                jj, ok := any(j).(uint)
                if ok </span><span class="cov3" title="2">{
                        return ii &gt; jj
                }</span>
        case uint8:<span class="cov0" title="0">
                jj, ok := any(j).(uint8)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        case uint16:<span class="cov0" title="0">
                jj, ok := any(j).(uint16)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        case uint32:<span class="cov3" title="2">
                jj, ok := any(j).(uint32)
                if ok </span><span class="cov3" title="2">{
                        return ii &gt; jj
                }</span>
        case uint64:<span class="cov0" title="0">
                jj, ok := any(j).(uint64)
                if ok </span><span class="cov0" title="0">{
                        return ii &gt; jj
                }</span>
        }
        <span class="cov0" title="0">panic(fmt.Sprintf("algos.types.GT[T any](i, j T): "+
                "Type of args is not processed: arg Type is %T", i))</span>
}

func EQ[T any](i, j T) bool <span class="cov10" title="12">{
        switch ii := any(i).(type) </span>{
        case STOrd:<span class="cov3" title="2">
                jj, ok := any(j).(STOrd)
                if ok </span><span class="cov3" title="2">{
                        return ii.CompareTo(jj) == 0
                }</span>
        case int:<span class="cov3" title="2">
                jj, ok := any(j).(int)
                if ok </span><span class="cov3" title="2">{
                        return ii == jj
                }</span>
        case int8:<span class="cov0" title="0">
                jj, ok := any(j).(int8)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        case int16:<span class="cov0" title="0">
                jj, ok := any(j).(int16)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        case int32:<span class="cov0" title="0">
                jj, ok := any(j).(int32)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        case int64:<span class="cov0" title="0">
                jj, ok := any(j).(int64)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        case float32:<span class="cov0" title="0">
                jj, ok := any(j).(float32)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        case float64:<span class="cov3" title="2">
                jj, ok := any(j).(float64)
                if ok </span><span class="cov3" title="2">{
                        return ii == jj
                }</span>
        case string:<span class="cov3" title="2">
                jj, ok := any(j).(string)
                if ok </span><span class="cov3" title="2">{
                        return ii == jj
                }</span>
        case uint:<span class="cov3" title="2">
                jj, ok := any(j).(uint)
                if ok </span><span class="cov3" title="2">{
                        return ii == jj
                }</span>
        case uint8:<span class="cov0" title="0">
                jj, ok := any(j).(uint8)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        case uint16:<span class="cov0" title="0">
                jj, ok := any(j).(uint16)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        case uint32:<span class="cov3" title="2">
                jj, ok := any(j).(uint32)
                if ok </span><span class="cov3" title="2">{
                        return ii == jj
                }</span>
        case uint64:<span class="cov0" title="0">
                jj, ok := any(j).(uint64)
                if ok </span><span class="cov0" title="0">{
                        return ii == jj
                }</span>
        }
        <span class="cov0" title="0">panic(fmt.Sprintf("algos.types.EQ[T any](i, j T): "+
                "Type of args is not processed: arg Type is %T", i))</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package types

import (
        "fmt"
)

type STOrd interface {
        CompareTo(STOrd) int
}

type Comp interface {
        Ptr | Ord
}

type Ord interface {
        Integer | Float | ~string
}

type Integer interface {
        Signed | Unsigned
}

type Ptr interface {
        ~uintptr
}

type Float interface {
        ~float32 | ~float64
}

type Unsigned interface {
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type Signed interface {
        ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Complex interface {
        ~complex64 | ~complex128
}

// ====================
type Option[O any] struct {
        val O
        def bool
}

func NewOptionSome[O any](val O) Option[O] <span class="cov4" title="9">{
        return Option[O]{
                val: val,
                def: true,
        }
}</span>

func NewOptionNone[O any]() Option[O] <span class="cov4" title="9">{
        return Option[O]{}
}</span>

func (opt Option[O]) IsDefined() bool <span class="cov10" title="231">{
        return opt.def
}</span>

func (opt Option[O]) Unbox(catch func() O) O <span class="cov4" title="11">{
        if opt.IsDefined() </span><span class="cov4" title="10">{
                return opt.val
        }</span>
        <span class="cov1" title="1">return catch()</span>
}

func (opt Option[O]) ToString() string <span class="cov2" title="2">{
        if opt.IsDefined() </span><span class="cov1" title="1">{
                return fmt.Sprintf("Some(%v)", opt.val)
        }</span>
        <span class="cov1" title="1">return "None"</span>
}

// ====================
type Either[L, R any] struct { // Either[L,R]{} - WRONG CONSTRUCTOR !  APPROPRIATE INIT REQUIRED
        l Option[L]
        r Option[R]
}

func NewEitherLeft[L, R any](left L) Either[L, R] <span class="cov2" title="2">{
        return Either[L, R]{
                l: NewOptionSome(left),
                r: NewOptionNone[R](),
        }
}</span>

func NewEitherRight[L, R any](right R) Either[L, R] <span class="cov2" title="2">{
        return Either[L, R]{
                l: NewOptionNone[L](),
                r: NewOptionSome(right),
        }
}</span>

func (eit Either[L, R]) isvalid() <span class="cov7" title="63">{
        bothNone := !eit.l.IsDefined() &amp;&amp; !eit.r.IsDefined()
        bothSome := eit.l.IsDefined() &amp;&amp; eit.r.IsDefined()
        if bothNone || bothSome </span><span class="cov5" title="15">{
                panic("algos.types.(Either[L,R]).isvalid() fails: There is a bad structure inside Either type")</span>
        }
}

func (eit Either[L, R]) IsLeft() bool <span class="cov5" title="18">{
        eit.isvalid()
        return eit.l.IsDefined()
}</span>

func (eit Either[L, R]) IsRight() bool <span class="cov5" title="17">{
        eit.isvalid()
        return eit.r.IsDefined()
}</span>

func (eit Either[L, R]) ValLeft() Option[L] <span class="cov4" title="8">{
        eit.isvalid()
        return eit.l
}</span>

func (eit Either[L, R]) ValRight() Option[R] <span class="cov4" title="9">{
        eit.isvalid()
        return eit.r
}</span>

func (eit Either[L, R]) Left(catch func() L) L <span class="cov3" title="4">{
        eit.isvalid()
        if eit.IsLeft() </span><span class="cov2" title="2">{
                return eit.l.Unbox(catch)
        }</span>
        <span class="cov1" title="1">return catch()</span>
}

func (eit Either[L, R]) Right(catch func() R) R <span class="cov3" title="4">{
        eit.isvalid()
        if eit.IsRight() </span><span class="cov2" title="2">{
                return eit.r.Unbox(catch)
        }</span>
        <span class="cov1" title="1">return catch()</span>
}

func (eit Either[L, R]) ToString() string <span class="cov2" title="3">{
        eit.isvalid()
        if eit.IsLeft() </span><span class="cov1" title="1">{
                return fmt.Sprintf("Left(%v)", eit.Left(func() L </span><span class="cov0" title="0">{
                        panic("algos.types.(Either[L,R]): cannot get L value")</span>
                }))
        }
        <span class="cov1" title="1">return fmt.Sprintf("Right(%v)", eit.Right(func() R </span><span class="cov0" title="0">{
                panic("algos.types.(Either[L,R]): cannot get R value")</span>
        }))
}

// ====================
type Result[T any] struct { // Result[T]]{} - WRONG CONSTRUCTOR ! APPROPRIATE INIT REQUIRED
        Either[error, T]
}

func NewResultError[T any](err error) Result[T] <span class="cov1" title="1">{
        return Result[T]{
                Either: NewEitherLeft[error, T](err),
        }
}</span>

func NewResult[T any](res T) Result[T] <span class="cov1" title="1">{
        return Result[T]{
                Either: NewEitherRight[error](res),
        }
}</span>

func (res Result[T]) IsErr() bool <span class="cov4" title="10">{
        return res.IsLeft()
}</span>

func (res Result[T]) IsRes() bool <span class="cov4" title="11">{
        return res.IsRight()
}</span>

func (res Result[T]) ValErr() Option[error] <span class="cov3" title="5">{
        return res.ValLeft()
}</span>

func (res Result[T]) ValRes() Option[T] <span class="cov3" title="6">{
        return res.ValRight()
}</span>

func (res Result[T]) Err(catch func() error) error <span class="cov3" title="4">{
        if res.IsErr() </span><span class="cov2" title="2">{
                return res.ValErr().Unbox(catch)
        }</span>
        <span class="cov1" title="1">return catch()</span>
}

func (res Result[T]) Res(catch func() T) T <span class="cov3" title="5">{
        if res.IsRes() </span><span class="cov2" title="3">{
                return res.ValRes().Unbox(catch)
        }</span>
        <span class="cov1" title="1">return catch()</span>
}

func (res Result[T]) Unbox(catch func() T) T <span class="cov2" title="3">{
        if res.IsRes() </span><span class="cov1" title="1">{
                return res.Res(catch)
        }</span>
        <span class="cov1" title="1">return catch()</span>
}

func (res Result[T]) ToString() string <span class="cov2" title="3">{
        if res.IsErr() </span><span class="cov1" title="1">{
                return fmt.Sprintf("Error(%v)", res.Err(func() error </span><span class="cov0" title="0">{
                        panic("algos.types.(Result): cannot get Error value")</span>
                }).Error())
        }
        <span class="cov1" title="1">return fmt.Sprintf("Result(%v)", res.Res(func() T </span><span class="cov0" title="0">{
                panic("algos.types.(Result): cannot get Result value")</span>
        }))
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
