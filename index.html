
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>array: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kselnaag/algos/array/func.go (100.0%)</option>
				
				<option value="file1">github.com/kselnaag/algos/array/hmap.go (91.7%)</option>
				
				<option value="file2">github.com/kselnaag/algos/array/pq.go (100.0%)</option>
				
				<option value="file3">github.com/kselnaag/algos/array/sort.go (83.4%)</option>
				
				<option value="file4">github.com/kselnaag/algos/array/stack.go (100.0%)</option>
				
				<option value="file5">github.com/kselnaag/algos/graph/uf.go (96.0%)</option>
				
				<option value="file6">github.com/kselnaag/algos/list/func.go (100.0%)</option>
				
				<option value="file7">github.com/kselnaag/algos/list/hmap.go (95.2%)</option>
				
				<option value="file8">github.com/kselnaag/algos/list/stack.go (98.3%)</option>
				
				<option value="file9">github.com/kselnaag/algos/math/math.go (100.0%)</option>
				
				<option value="file10">github.com/kselnaag/algos/tree/rbtree.go (0.0%)</option>
				
				<option value="file11">github.com/kselnaag/algos/types/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package array

func Map[T1, T2 any](arr []T1, fnc func(T1) T2) []T2 <span class="cov3" title="2">{
        res := make([]T2, 0, len(arr))
        for _, el := range arr </span><span class="cov7" title="10">{
                res = append(res, fnc(el))
        }</span>
        <span class="cov3" title="2">return res</span>
}

func MapA[T1, T2 any](arr []T1, fnc func(T1) T2) []T2 <span class="cov3" title="2">{
        res := make([]T2, 0, len(arr))
        chans := make(chan chan T2, len(arr))
        for _, el := range arr </span><span class="cov7" title="10">{
                elemChan := make(chan T2)
                chans &lt;- elemChan
                go func(elemChan chan&lt;- T2, el T1) </span><span class="cov7" title="10">{
                        elemChan &lt;- fnc(el)
                }</span>(elemChan, el)
        }
        <span class="cov3" title="2">close(chans)
        for elemChan := range chans </span><span class="cov7" title="10">{
                res = append(res, &lt;-elemChan)
        }</span>
        <span class="cov3" title="2">return res</span>
}

func Reduce[T1, T2 any](arr []T1, fnc func(T2, T1) T2, acc T2) T2 <span class="cov3" title="2">{
        for _, el := range arr </span><span class="cov7" title="10">{
                acc = fnc(acc, el)
        }</span>
        <span class="cov3" title="2">return acc</span>
}

func ReduceR[T1, T2 any](arr []T1, fnc func(T2, T1) T2, acc T2) T2 <span class="cov3" title="2">{
        alen := len(arr)
        for i := alen - 1; i &gt;= 0; i-- </span><span class="cov7" title="10">{
                acc = fnc(acc, arr[i])
        }</span>
        <span class="cov3" title="2">return acc</span>
}

func Filter[T any](arr []T, fnc func(T) bool) []T <span class="cov4" title="3">{
        res := make([]T, 0)
        for _, el := range arr </span><span class="cov10" title="20">{
                if fnc(el) </span><span class="cov7" title="10">{
                        res = append(res, el)
                }</span>
        }
        <span class="cov4" title="3">return res</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package array

import (
        "math"

        amath "github.com/kselnaag/algos/math"
        I "github.com/kselnaag/algos/types"
)

type Anode[K I.Ord, V any] struct {
        Key K
        Val V
}

type Hmap[K I.Ord, V any] struct {
        hmarr   [math.MaxUint16]*[]Anode[K, V]
        keysnum int
}

func NewHmap[K I.Ord, V any]() Hmap[K, V] <span class="cov1" title="1">{
        return Hmap[K, V]{
                hmarr:   [math.MaxUint16]*[]Anode[K, V]{},
                keysnum: 0,
        }
}</span>

func (hm *Hmap[K, V]) Size() int <span class="cov2" title="8">{
        return hm.keysnum
}</span>

func (hm *Hmap[K, V]) IsEmpty() bool <span class="cov2" title="4">{
        return hm.Size() == 0
}</span>

func (hm *Hmap[K, V]) Set(key K, val V) <span class="cov2" title="11">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        node := Anode[K, V]{Key: key, Val: val}
        if hm.hmarr[int(hash)] == nil </span><span class="cov2" title="9">{
                hm.hmarr[int(hash)] = &amp;[]Anode[K, V]{node}
                hm.keysnum++
                return
        }</span>
        <span class="cov1" title="2">for i, hnode := range *hm.hmarr[int(hash)] </span><span class="cov1" title="2">{
                if hnode.Key == key </span><span class="cov1" title="2">{
                        (*hm.hmarr[int(hash)])[i] = node
                        return
                }</span>
        }
        <span class="cov0" title="0">*hm.hmarr[int(hash)] = append(*hm.hmarr[int(hash)], node)
        hm.keysnum++</span>
}

func (hm *Hmap[K, V]) IsKey(key K) bool <span class="cov2" title="6">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        if hm.hmarr[int(hash)] == nil </span><span class="cov1" title="2">{
                return false
        }</span>
        <span class="cov2" title="4">for _, hnode := range *hm.hmarr[int(hash)] </span><span class="cov1" title="3">{
                if hnode.Key == key </span><span class="cov1" title="3">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func (hm *Hmap[K, V]) Get(key K) V <span class="cov2" title="4">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        if hm.hmarr[int(hash)] == nil </span><span class="cov1" title="2">{
                panic("algos.array.(Hmap).Get(key K): No any key found, check first")</span>
        }
        <span class="cov1" title="2">for _, hnode := range *hm.hmarr[int(hash)] </span><span class="cov1" title="2">{
                if hnode.Key == key </span><span class="cov1" title="2">{
                        return hnode.Val
                }</span>
        }
        <span class="cov0" title="0">panic("algos.array.(Hmap).Get(key K): No any key found, check first")</span>
}

func (hm *Hmap[K, V]) Del(key K) <span class="cov1" title="2">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        if hm.hmarr[int(hash)] == nil </span><span class="cov1" title="1">{
                panic("algos.array.(Hmap).Del(key K): No any key found, check first")</span>
        }
        <span class="cov1" title="1">for i, hnode := range *hm.hmarr[int(hash)] </span><span class="cov1" title="1">{
                if hnode.Key == key </span><span class="cov1" title="1">{
                        *hm.hmarr[int(hash)] = append((*hm.hmarr[int(hash)])[:i], (*hm.hmarr[int(hash)])[i+1:]...)
                        hm.keysnum--
                        return
                }</span>
        }
        <span class="cov0" title="0">panic("algos.array.(Hmap).Del(key K): No any key found, check first")</span>
}

func (hm *Hmap[K, V]) IterateKeys() []K <span class="cov1" title="1">{
        res := []K{}
        for _, ptr := range hm.hmarr </span><span class="cov10" title="65535">{
                if ptr != nil </span><span class="cov2" title="9">{
                        for _, kvnode := range *ptr </span><span class="cov2" title="8">{
                                res = append(res, kvnode.Key)
                        }</span>
                }
        }
        <span class="cov1" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package array

import (
        I "github.com/kselnaag/algos/types"
)

// ===========================
type MinPQ[T any] struct {
        pq   []T
        size int
}

func NewMinPQ[T any]() MinPQ[T] <span class="cov5" title="6">{
        return MinPQ[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (min *MinPQ[T]) Size() int <span class="cov9" title="30">{
        return min.size
}</span>

func (min *MinPQ[T]) IsEmpty() bool <span class="cov7" title="15">{
        return min.Size() == 0
}</span>

func (min *MinPQ[T]) swim(k int) <span class="cov10" title="42">{
        for (k &gt; 1) &amp;&amp; I.GT(min.pq[k/2], min.pq[k]) </span><span class="cov9" title="36">{
                swap(min.pq, k/2, k)
                k /= 2
        }</span>
}
func (min *MinPQ[T]) sink(k int) <span class="cov8" title="21">{
        for (2 * k) &lt;= min.size </span><span class="cov8" title="21">{
                j := 2 * k
                if (j &lt; min.size) &amp;&amp; I.GT(min.pq[j], min.pq[j+1]) </span><span class="cov5" title="6">{
                        j++
                }</span>
                <span class="cov8" title="21">if !I.GT(min.pq[k], min.pq[j]) </span><span class="cov6" title="9">{
                        break</span>
                }
                <span class="cov6" title="12">swap(min.pq, k, j)
                k = j</span>
        }
}

func (min *MinPQ[T]) Add(val T) <span class="cov10" title="42">{
        min.size++
        if len(min.pq) &gt; min.size </span><span class="cov8" title="21">{
                min.pq[min.size] = val
        }</span> else<span class="cov8" title="21"> {
                min.pq = append(min.pq, val)
        }</span>
        <span class="cov10" title="42">min.swim(min.size)</span>
}

func (min *MinPQ[T]) Min() T <span class="cov6" title="9">{
        if min.size &lt; 1 </span><span class="cov3" title="3">{
                panic("algos.array.(MinPQ).Min(): Queue is empty ")</span>
        }
        <span class="cov5" title="6">return min.pq[1]</span>
}

func (min *MinPQ[T]) GetMin() T <span class="cov8" title="24">{
        if min.size &lt; 1 </span><span class="cov3" title="3">{
                panic("algos.array.(MinPQ).GetMin(): Queue is empty ")</span>
        }
        <span class="cov8" title="21">ret := min.pq[1]
        swap(min.pq, 1, min.size)
        min.size--
        min.sink(1)
        return ret</span>
}

func (min *MinPQ[T]) Iterate() []T <span class="cov3" title="3">{
        return min.pq[1:(min.size + 1)]
}</span>

// ===========================
type MaxPQ[T any] struct {
        pq   []T
        size int
}

func NewMaxPQ[T any]() MaxPQ[T] <span class="cov5" title="6">{
        return MaxPQ[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (max *MaxPQ[T]) Size() int <span class="cov9" title="30">{
        return max.size
}</span>

func (max *MaxPQ[T]) IsEmpty() bool <span class="cov7" title="15">{
        return max.Size() == 0
}</span>

func (max *MaxPQ[T]) swim(k int) <span class="cov10" title="42">{
        for (k &gt; 1) &amp;&amp; I.LT(max.pq[k/2], max.pq[k]) </span><span class="cov5" title="6">{
                swap(max.pq, k/2, k)
                k /= 2
        }</span>
}
func (max *MaxPQ[T]) sink(k int) <span class="cov8" title="21">{
        for (2 * k) &lt;= max.size </span><span class="cov8" title="24">{
                j := 2 * k
                if (j &lt; max.size) &amp;&amp; I.LT(max.pq[j], max.pq[j+1]) </span><span class="cov5" title="6">{
                        j++
                }</span>
                <span class="cov8" title="24">if !I.LT(max.pq[k], max.pq[j]) </span><span class="cov5" title="6">{
                        break</span>
                }
                <span class="cov7" title="18">swap(max.pq, k, j)
                k = j</span>
        }
}

func (max *MaxPQ[T]) Add(val T) <span class="cov10" title="42">{
        max.size++
        if len(max.pq) &gt; max.size </span><span class="cov8" title="21">{
                max.pq[max.size] = val
        }</span> else<span class="cov8" title="21"> {
                max.pq = append(max.pq, val)
        }</span>
        <span class="cov10" title="42">max.swim(max.size)</span>
}

func (max *MaxPQ[T]) Max() T <span class="cov6" title="9">{
        if max.size &lt; 1 </span><span class="cov3" title="3">{
                panic("algos.array.(MaxPQ).Max(): Queue is empty ")</span>
        }
        <span class="cov5" title="6">return max.pq[1]</span>
}

func (max *MaxPQ[T]) GetMax() T <span class="cov8" title="24">{
        if max.size &lt; 1 </span><span class="cov3" title="3">{
                panic("algos.array.(MaxPQ).GetMax(): Queue is empty ")</span>
        }
        <span class="cov8" title="21">ret := max.pq[1]
        swap(max.pq, 1, max.size)
        max.size--
        max.sink(1)
        return ret</span>
}

func (max *MaxPQ[T]) Iterate() []T <span class="cov3" title="3">{
        return max.pq[1:(max.size + 1)]
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package array

import (
        "math/rand"

        I "github.com/kselnaag/algos/types"
)

func Quick3Sort[T any](arr []T) <span class="cov5" title="43">{
        Shuffle(arr)
        q3sort(arr, 0, len(arr)-1)
}</span>

func q3sort[T any](arr []T, lo, hi int) <span class="cov7" title="279">{
        if hi &lt;= lo </span><span class="cov6" title="161">{
                return
        }</span>
        <span class="cov6" title="118">l, i, v, g := lo, lo+1, arr[lo], hi
        for i &lt;= g </span><span class="cov7" title="427">{
                if I.LT(arr[i], v) </span><span class="cov6" title="217">{
                        swap(arr, l, i)
                        l++
                        i++
                }</span> else<span class="cov6" title="210"> if I.GT(arr[i], v) </span><span class="cov6" title="210">{
                        swap(arr, i, g)
                        g--
                }</span> else<span class="cov0" title="0"> {
                        i++
                }</span>
        }
        <span class="cov6" title="118">q3sort(arr, lo, l-1)
        q3sort(arr, g+1, hi)</span>
}

func HeapSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        for k := alen / 2; k &gt; 0; k-- </span><span class="cov5" title="87">{
                sink(arr, k, alen-1)
        }</span>
        <span class="cov5" title="43">for n := alen - 1; n &gt; 1; </span><span class="cov6" title="128">{
                swap(arr, 1, n)
                n--
                sink(arr, 1, n)
        }</span>
}

func sink[T any](arr []T, k, n int) <span class="cov6" title="215">{
        for (2 * k) &lt;= n </span><span class="cov7" title="343">{
                j := 2 * k
                if (j &lt; n) &amp;&amp; I.LT(arr[j], arr[j+1]) </span><span class="cov6" title="140">{
                        j++
                }</span>
                <span class="cov7" title="343">if !I.LT(arr[k], arr[j]) </span><span class="cov3" title="11">{
                        break</span>
                }
                <span class="cov7" title="332">swap(arr, k, j)
                k = j</span>
        }
}

func QuickSort[T any](arr []T) <span class="cov5" title="43">{
        Shuffle(arr)
        qsort(arr, 0, len(arr)-1)
}</span>

func qsort[T any](arr []T, lo, hi int) <span class="cov6" title="127">{
        if hi &lt;= lo </span><span class="cov5" title="50">{
                return
        }</span>
        <span class="cov5" title="77">if (hi - lo + 1) &lt;= 12 </span><span class="cov4" title="35">{
                InsertSort(arr)
                return
        }</span>
        <span class="cov5" title="42">j := pivot(arr, lo, hi)
        qsort(arr, lo, j-1)
        qsort(arr, j+1, hi)</span>
}

func pivot[T any](arr []T, lo, hi int) int <span class="cov5" title="42">{
        i, j, v := lo, hi, lo
        for </span><span class="cov6" title="183">{
                for ; I.LT(arr[i], arr[v]); i++ </span><span class="cov0" title="0">{
                        if i == hi </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov6" title="183">for ; I.LT(arr[v], arr[j]); j-- </span><span class="cov8" title="777">{
                        if j == lo </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov6" title="183">if i &gt;= j </span><span class="cov5" title="42">{
                        break</span>
                }
                <span class="cov6" title="141">swap(arr, i, j)</span>
        }
        <span class="cov5" title="42">swap(arr, lo, j)
        return j</span>
}

func MergeSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        aux := make([]T, alen)
        copy(aux, arr)
        mrgsort(aux, arr, 0, alen-1)
}</span>

func mrgsort[T any](src []T, dst []T, lo, hi int) <span class="cov5" title="61">{
        if hi &lt;= lo </span><span class="cov3" title="8">{
                return
        }</span>
        <span class="cov5" title="53">if (hi - lo + 1) &lt;= 12 </span><span class="cov5" title="44">{
                InsertSort(src[lo : hi+1])
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov3" title="9">mid := lo + (hi-lo)/2
        mrgsort(dst, src, lo, mid)
        mrgsort(dst, src, mid+1, hi)
        merge(src, dst, lo, mid, hi)</span>
}

func merge[T any](src []T, dst []T, lo, mid, hi int) <span class="cov3" title="9">{
        if !I.GT(src[mid], src[mid+1]) </span><span class="cov3" title="9">{
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov0" title="0">i, j := lo, mid+1
        for k := lo; k &lt;= hi; k++ </span><span class="cov0" title="0">{
                if i &gt; mid </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                        continue</span>
                }
                <span class="cov0" title="0">if j &gt; hi </span><span class="cov0" title="0">{
                        dst[k] = src[i]
                        i++
                        continue</span>
                }
                <span class="cov0" title="0">if I.LT(src[j], src[i]) </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                }</span> else<span class="cov0" title="0"> {
                        dst[k] = src[i]
                        i++
                }</span>
        }
}

func ReverseSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov5" title="87">{
                min := i
                max := i
                for j := i + 1; j &lt; (alen - i); j++ </span><span class="cov8" title="635">{
                        if I.LT(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                        <span class="cov8" title="635">if I.GT(arr[j], arr[max]) </span><span class="cov8" title="635">{
                                max = j
                        }</span>
                }
                <span class="cov5" title="87">if max == i </span><span class="cov0" title="0">{
                        if min == (alen - i - 1) </span><span class="cov0" title="0">{
                                swap(arr, max, min)
                        }</span> else<span class="cov0" title="0"> {
                                swap(arr, (alen - i - 1), max)
                                swap(arr, i, min)
                        }</span>
                } else<span class="cov5" title="87"> {
                        swap(arr, i, min)
                        swap(arr, (alen - i - 1), max)
                }</span>
        }
}

func SelectSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov6" title="203">{
                min := i
                for j := i + 1; j &lt; alen; j++ </span><span class="cov8" title="1183">{
                        if I.LT(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                }
                <span class="cov6" title="203">swap(arr, i, min)</span>
        }
}

func ShellSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        h := 1
        for h &lt; (alen / 3) </span><span class="cov3" title="14">{
                h = 3*h + 1
        }</span>
        <span class="cov5" title="43">for h &gt; 0 </span><span class="cov5" title="57">{
                for i := h; i &lt; alen; i++ </span><span class="cov7" title="288">{
                        for j := i; j &gt;= h; j -= h </span><span class="cov7" title="288">{
                                if I.LT(arr[j], arr[j-h]) </span><span class="cov0" title="0">{
                                        swap(arr, j, j-h)
                                }</span> else<span class="cov7" title="288"> {
                                        break</span>
                                }
                        }
                }
                <span class="cov5" title="57">h = h / 3</span>
        }
}

func InsertSort[T any](arr []T) <span class="cov6" title="122">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov7" title="480">{
                for j := i; j &gt; 0; j-- </span><span class="cov9" title="1597">{
                        if I.LT(arr[j], arr[j-1]) </span><span class="cov8" title="1255">{
                                swap(arr, j, j-1)
                        }</span> else<span class="cov7" title="342"> {
                                break</span>
                        }
                }
        }
}

func BinarySearch[T any](arr []T, elem T) int <span class="cov2" title="3">{
        low := 0
        high := len(arr)
        for low &lt; high </span><span class="cov2" title="6">{
                mid := (low + ((high - low) / 2))
                val := arr[mid]
                if I.EQ(val, elem) </span><span class="cov1" title="1">{
                        return mid
                }</span> else<span class="cov2" title="5"> if I.GT(val, elem) </span><span class="cov1" title="1">{
                        high = mid
                }</span> else<span class="cov2" title="4"> if I.LT(val, elem) </span><span class="cov2" title="4">{
                        low = mid + 1
                }</span>
        }
        <span class="cov1" title="2">return -1</span>
}

func Shuffle[T any](arr []T) <span class="cov5" title="88">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov7" title="419">{
                j := rand.Intn(i + 1)
                swap(arr, i, j)
        }</span>
}

func Reverse[T any](arr []T) <span class="cov3" title="9">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov4" title="27">{
                swap(arr, i, alen-i-1)
        }</span>
}

func Contained[T any](arr []T, elem T) int <span class="cov2" title="3">{
        for i, el := range arr </span><span class="cov2" title="6">{
                if I.EQ(el, elem) </span><span class="cov1" title="1">{
                        return i
                }</span>
        }
        <span class="cov1" title="2">return -1</span>
}

func IsSorted[T any](arr []T) bool <span class="cov2" title="4">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov3" title="14">{
                if I.LT(arr[i], arr[i-1]) </span><span class="cov1" title="2">{
                        return false
                }</span>
        }
        <span class="cov1" title="2">return true</span>
}

func swap[T any](arr []T, i, j int) <span class="cov10" title="3262">{
        arr[i], arr[j] = arr[j], arr[i]
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package array

// ===========================
type Bag[T any] struct {
        arr  []T
        size int
}

func NewBag[T any]() Bag[T] <span class="cov1" title="1">{
        return Bag[T]{
                arr:  make([]T, 0, 8),
                size: 0,
        }
}</span>

func (b *Bag[T]) Size() int <span class="cov7" title="6">{
        return b.size
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov4" title="3">{
        return b.Size() == 0
}</span>

func (b *Bag[T]) Add(val T) <span class="cov7" title="7">{
        b.arr = append(b.arr, val)
        b.size++
}</span>

func (b *Bag[T]) Iterate() []T <span class="cov3" title="2">{
        return b.arr
}</span>

func (b *Bag[T]) Reverse() <span class="cov1" title="1">{
        Reverse(b.arr)
}</span>

// ===========================
type Stack[T any] struct {
        arr  []T
        size int
}

func NewStack[T any]() Stack[T] <span class="cov3" title="2">{
        return Stack[T]{
                arr:  make([]T, 0, 8),
                size: 0,
        }
}</span>

func (s *Stack[T]) Size() int <span class="cov8" title="9">{
        return s.size
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov5" title="4">{
        return s.Size() == 0
}</span>

func (s *Stack[T]) Push(val T) <span class="cov10" title="14">{
        s.arr = append(s.arr, val)
        s.size++
}</span>

func (s *Stack[T]) Pop() T <span class="cov8" title="8">{
        last := len(s.arr) - 1
        ret := s.arr[last]
        s.arr = s.arr[:last]
        s.size--
        return ret
}</span>

func (s *Stack[T]) Iterate() []T <span class="cov1" title="1">{
        return s.arr
}</span>

func (s *Stack[T]) Reverse() <span class="cov1" title="1">{
        Reverse(s.arr)
}</span>

// ===========================
type Queue[T any] struct {
        arr  []T
        size int
}

func NewQueue[T any]() Queue[T] <span class="cov3" title="2">{
        return Queue[T]{
                arr:  make([]T, 0, 8),
                size: 0,
        }
}</span>

func (q *Queue[T]) Size() int <span class="cov8" title="9">{
        return q.size
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov5" title="4">{
        return q.Size() == 0
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov10" title="14">{
        q.arr = append(q.arr, val)
        q.size++
}</span>

func (q *Queue[T]) Deq() T <span class="cov8" title="8">{
        ret := q.arr[0]
        q.arr = q.arr[1:]
        q.size--
        return ret
}</span>

func (q *Queue[T]) Iterate() []T <span class="cov1" title="1">{
        return q.arr
}</span>

func (q *Queue[T]) Reverse() <span class="cov1" title="1">{
        Reverse(q.arr)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package graph

import (
        "github.com/kselnaag/algos/array"
        "github.com/kselnaag/algos/math"
)

type UF struct {
        id    []int
        bag   array.Bag[int]
        count int
        size  int
}

func NewUF(n int) UF <span class="cov1" title="1">{
        n = math.Abs(n)
        arr := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov6" title="10">{
                arr[i] = i
        }</span>
        <span class="cov1" title="1">return UF{
                id:    arr,
                bag:   array.NewBag[int](),
                count: n,
                size:  n,
        }</span>
}

func (uf *UF) Union(p, q int) <span class="cov5" title="8">{
        pRoot := uf.Find(p)
        qRoot := uf.Find(q)
        if pRoot == qRoot </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="8">uf.id[qRoot] = pRoot
        uf.count--</span>
}

func (uf *UF) Find(p int) int <span class="cov10" title="50">{
        p = math.Abs(p)
        for p != uf.id[p] </span><span class="cov8" title="29">{
                uf.bag.Add(p)
                p = uf.id[p]
        }</span>
        // path compression
        <span class="cov10" title="50">blen := uf.bag.Size()
        barr := uf.bag.Iterate()
        for i := 0; i &lt; blen; i++ </span><span class="cov8" title="29">{
                t := barr[i]
                uf.id[t] = p
        }</span>
        <span class="cov10" title="50">uf.bag = array.NewBag[int]()
        return p</span>
}

func (uf *UF) Connected(p, q int) bool <span class="cov5" title="7">{
        return uf.Find(p) == uf.Find(q)
}</span>

func (uf *UF) Count() int <span class="cov3" title="3">{
        return uf.count
}</span>

func (uf *UF) Size() int <span class="cov3" title="3">{
        return uf.size
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package list

func Map[T1, T2 any](root *Snode[T1], fnc func(T1) T2) *Snode[T2] <span class="cov5" title="6">{
        var res, ptr *Snode[T2]
        for onode := root; onode != nil; onode = onode.Next </span><span class="cov10" title="40">{
                nnode := &amp;Snode[T2]{Val: fnc(onode.Val), Next: nil}
                if onode == root </span><span class="cov4" title="5">{
                        res = nnode
                }</span> else<span class="cov9" title="35"> {
                        ptr.Next = nnode
                }</span>
                <span class="cov10" title="40">ptr = nnode</span>
        }
        <span class="cov5" title="6">return res</span>
}

func MapA[T1, T2 any](root *Snode[T1], fnc func(T1) T2) *Snode[T2] <span class="cov2" title="2">{
        llen := ListSize(root)
        chans := make(chan chan T2, llen)
        for node := root; node != nil; node = node.Next </span><span class="cov6" title="10">{
                elemChan := make(chan T2)
                chans &lt;- elemChan
                go func(elemChan chan&lt;- T2, el T1) </span><span class="cov6" title="10">{
                        elemChan &lt;- fnc(el)
                }</span>(elemChan, node.Val)
        }
        <span class="cov2" title="2">close(chans)
        var res, ptr *Snode[T2]
        i := 0
        for elemChan := range chans </span><span class="cov6" title="10">{
                node := &amp;Snode[T2]{Val: &lt;-elemChan, Next: nil}
                if i == 0 </span><span class="cov1" title="1">{
                        res = node
                }</span> else<span class="cov6" title="9"> {
                        ptr.Next = node
                }</span>
                <span class="cov6" title="10">ptr = node
                i++</span>
        }
        <span class="cov2" title="2">return res</span>
}

func Reduce[T1, T2 any](root *Snode[T1], fnc func(T2, T1) T2, acc T2) T2 <span class="cov2" title="2">{
        for node := root; node != nil; node = node.Next </span><span class="cov6" title="10">{
                acc = fnc(acc, node.Val)
        }</span>
        <span class="cov2" title="2">return acc</span>
}

func ReduceR[T1, T2 any](root *Snode[T1], fnc func(T2, T1) T2, acc T2) T2 <span class="cov7" title="12">{
        if root == nil </span><span class="cov2" title="2">{
                return acc
        }</span>
        <span class="cov6" title="10">return fnc(ReduceR(root.Next, fnc, acc), root.Val)</span>
}

func Filter[T any](root *Snode[T], fnc func(T) bool) *Snode[T] <span class="cov3" title="3">{
        var res, ptr *Snode[T]
        for onode := root; onode != nil; onode = onode.Next </span><span class="cov8" title="20">{
                node := &amp;Snode[T]{Val: onode.Val, Next: nil}
                if fnc(node.Val) </span><span class="cov6" title="10">{
                        if res == nil </span><span class="cov2" title="2">{
                                res = node
                        }</span> else<span class="cov6" title="8"> {
                                ptr.Next = node
                        }</span>
                        <span class="cov6" title="10">ptr = node</span>
                }
        }
        <span class="cov3" title="3">return res</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package list

import (
        "math"

        amath "github.com/kselnaag/algos/math"
        I "github.com/kselnaag/algos/types"
)

type Mnode[K I.Ord, V any] struct {
        Key  K
        Val  V
        Next *Mnode[K, V]
}

type Hmap[K I.Ord, V any] struct {
        hmarr   [math.MaxUint16]*Mnode[K, V]
        keysnum int
}

func NewHmap[K I.Ord, V any]() Hmap[K, V] <span class="cov1" title="1">{
        return Hmap[K, V]{
                hmarr:   [math.MaxUint16]*Mnode[K, V]{},
                keysnum: 0,
        }
}</span>

func (hm *Hmap[K, V]) Size() int <span class="cov2" title="8">{
        return hm.keysnum
}</span>

func (hm *Hmap[K, V]) IsEmpty() bool <span class="cov2" title="4">{
        return hm.Size() == 0
}</span>

func (hm *Hmap[K, V]) Set(key K, val V) <span class="cov2" title="11">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        setnode := &amp;Mnode[K, V]{Key: key, Val: val, Next: nil}
        for node := hm.hmarr[int(hash)]; node != nil; node = node.Next </span><span class="cov1" title="2">{
                if node.Key == key </span><span class="cov1" title="2">{
                        node.Val = val
                        return
                }</span>
        }
        <span class="cov2" title="9">setnode.Next = hm.hmarr[int(hash)]
        hm.hmarr[int(hash)] = setnode
        hm.keysnum++</span>
}

func (hm *Hmap[K, V]) IsKey(key K) bool <span class="cov2" title="6">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        for node := hm.hmarr[int(hash)]; node != nil; node = node.Next </span><span class="cov1" title="3">{
                if node.Key == key </span><span class="cov1" title="3">{
                        return true
                }</span>
        }
        <span class="cov1" title="3">return false</span>
}

func (hm *Hmap[K, V]) Get(key K) V <span class="cov2" title="4">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        for node := hm.hmarr[int(hash)]; node != nil; node = node.Next </span><span class="cov1" title="2">{
                if node.Key == key </span><span class="cov1" title="2">{
                        return node.Val
                }</span>
        }
        <span class="cov1" title="2">panic("algos.list.(Hmap).Get(key K): No any key found, check first")</span>
}

func (hm *Hmap[K, V]) Del(key K) <span class="cov1" title="2">{
        abytes := I.ConvToByteArr(key)
        hash := amath.HashPirson16(abytes)
        prev := hm.hmarr[int(hash)]
        for node := hm.hmarr[int(hash)]; node != nil; node = node.Next </span><span class="cov1" title="1">{
                if node.Key == key </span><span class="cov1" title="1">{
                        if prev == hm.hmarr[int(hash)] </span><span class="cov1" title="1">{
                                hm.hmarr[int(hash)] = node.Next
                        }</span> else<span class="cov0" title="0"> {
                                prev.Next = node.Next
                        }</span>
                        <span class="cov1" title="1">hm.keysnum--
                        return</span>
                }
                <span class="cov0" title="0">prev = node</span>
        }
        <span class="cov1" title="1">panic("algos.list.(Hmap).Del(key K): No any key found, check first")</span>
}

func (hm *Hmap[K, V]) IterateKeys() []K <span class="cov1" title="1">{
        res := []K{}
        for _, ptr := range hm.hmarr </span><span class="cov10" title="65535">{
                for node := ptr; node != nil; node = node.Next </span><span class="cov2" title="8">{
                        res = append(res, node.Key)
                }</span>
        }
        <span class="cov1" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package list

type Snode[T any] struct {
        Val  T
        Next *Snode[T]
}

func Reverse[T any](first *Snode[T]) *Snode[T] <span class="cov10" title="21">{
        if first == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="21">if first.Next == nil </span><span class="cov4" title="3">{
                return first
        }</span>
        <span class="cov9" title="18">second := first.Next
        root := Reverse(second)
        second.Next = first
        first.Next = nil
        return root</span>
}

func ListSize[T any](root *Snode[T]) int <span class="cov3" title="2">{
        size := 0
        if root == nil </span><span class="cov1" title="1">{
                return size
        }</span>
        <span class="cov1" title="1">for node := root; node != nil; node = node.Next </span><span class="cov7" title="10">{
                size++
        }</span>
        <span class="cov1" title="1">return size</span>
}

// ===========================
type Bag[T any] struct {
        first *Snode[T]
        size  int
}

func NewBag[T any]() Bag[T] <span class="cov1" title="1">{
        return Bag[T]{
                first: nil,
                size:  0,
        }
}</span>

func (b *Bag[T]) Size() int <span class="cov6" title="6">{
        return b.size
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov4" title="3">{
        return b.Size() == 0
}</span>

func (b *Bag[T]) Add(val T) <span class="cov6" title="7">{
        b.first = &amp;Snode[T]{Val: val, Next: b.first}
        b.size++
}</span>

func (b *Bag[T]) Iterate() []T <span class="cov3" title="2">{
        res := make([]T, 0, b.size)
        for node := b.first; node != nil; node = node.Next </span><span class="cov8" title="14">{
                res = append(res, node.Val)
        }</span>
        <span class="cov3" title="2">return res</span>
}

func (b *Bag[T]) Reverse() <span class="cov1" title="1">{
        b.first = Reverse(b.first)
}</span>

// ===========================
type Stack[T any] struct {
        first *Snode[T]
        size  int
}

func NewStack[T any]() Stack[T] <span class="cov3" title="2">{
        return Stack[T]{
                first: nil,
                size:  0,
        }
}</span>

func (s *Stack[T]) Size() int <span class="cov7" title="9">{
        return s.size
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov5" title="4">{
        return s.Size() == 0
}</span>

func (s *Stack[T]) Push(val T) <span class="cov8" title="14">{
        s.first = &amp;Snode[T]{Val: val, Next: s.first}
        s.size++
}</span>

func (s *Stack[T]) Pop() T <span class="cov7" title="8">{
        ret := s.first.Val
        s.first = s.first.Next
        s.size--
        return ret
}</span>

func (s *Stack[T]) Iterate() []T <span class="cov1" title="1">{
        res := make([]T, 0, s.size)
        for node := s.first; node != nil; node = node.Next </span><span class="cov6" title="7">{
                res = append(res, node.Val)
        }</span>
        <span class="cov1" title="1">return res</span>
}

func (s *Stack[T]) Reverse() <span class="cov1" title="1">{
        s.first = Reverse(s.first)
}</span>

// ===========================
type Queue[T any] struct {
        first *Snode[T]
        last  *Snode[T]
        size  int
}

func NewQueue[T any]() Queue[T] <span class="cov3" title="2">{
        return Queue[T]{
                first: nil,
                last:  nil,
                size:  0,
        }
}</span>

func (q *Queue[T]) Size() int <span class="cov7" title="9">{
        return q.size
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov5" title="4">{
        return q.Size() == 0
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov8" title="14">{
        newnode := &amp;Snode[T]{Val: val, Next: nil}
        if q.size == 0 </span><span class="cov3" title="2">{
                q.first = newnode
        }</span> else<span class="cov8" title="12"> {
                q.last.Next = newnode
        }</span>
        <span class="cov8" title="14">q.last = newnode
        q.size++</span>
}

func (q *Queue[T]) Deq() T <span class="cov7" title="8">{
        ret := q.first.Val
        q.first = q.first.Next
        q.size--
        if (q.size == 0) || (q.size == 1) </span><span class="cov3" title="2">{
                q.last = q.first
        }</span>
        <span class="cov6" title="7">return ret</span>
}

func (q *Queue[T]) Iterate() []T <span class="cov1" title="1">{
        res := make([]T, 0, q.size)
        for node := q.first; node != nil; node = node.Next </span><span class="cov6" title="7">{
                res = append(res, node.Val)
        }</span>
        <span class="cov1" title="1">return res</span>
}

func (q *Queue[T]) Reverse() <span class="cov1" title="1">{
        q.last = q.first
        q.first = Reverse(q.first)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package math

import (
        I "github.com/kselnaag/algos/types"
)

func HashPirson16(mess []byte) uint16 <span class="cov2" title="3">{
        T := [256]byte{
                130, 4, 133, 49, 108, 178, 125, 95, 35, 126, 41, 129, 229, 48, 6, 94, 206,
                69, 20, 194, 236, 79, 156, 67, 100, 239, 152, 149, 93, 91, 56, 8, 183, 165,
                42, 148, 114, 59, 57, 5, 112, 151, 54, 97, 109, 145, 228, 196, 250, 104,
                169, 107, 86, 64, 98, 181, 200, 58, 199, 70, 138, 179, 60, 249, 34, 123,
                30, 22, 124, 240, 201, 132, 218, 21, 74, 83, 39, 223, 73, 88, 136, 27, 0,
                10, 89, 51, 215, 251, 255, 3, 235, 241, 19, 102, 71, 38, 166, 220, 110, 23,
                232, 25, 172, 210, 142, 211, 121, 242, 75, 208, 195, 203, 226, 253, 176, 17,
                66, 158, 231, 237, 99, 254, 173, 221, 117, 139, 213, 90, 85, 45, 187, 84, 92,
                44, 164, 247, 122, 32, 127, 177, 170, 155, 111, 185, 171, 61, 76, 184, 234, 192,
                16, 106, 160, 204, 153, 161, 186, 131, 28, 137, 37, 216, 248, 55, 72, 50, 26,
                46, 53, 224, 7, 217, 189, 120, 219, 167, 119, 11, 252, 65, 135, 96, 222, 68,
                144, 214, 227, 101, 207, 103, 212, 175, 157, 141, 168, 82, 163, 47, 52, 15, 113,
                230, 245, 116, 43, 80, 246, 33, 198, 197, 146, 193, 13, 31, 24, 143, 12, 18, 118,
                14, 62, 154, 78, 81, 134, 162, 105, 63, 244, 77, 190, 209, 150, 233, 159, 202, 191,
                40, 87, 180, 188, 36, 238, 9, 140, 128, 147, 174, 1, 2, 182, 243, 29, 115, 205, 225,
        }
        result := uint16(0)
        mlen := len(mess)
        hash := T[mlen%256]
        for j := 0; j &lt; 2; j++ </span><span class="cov3" title="6">{
                for i := 0; i &lt; mlen; i++ </span><span class="cov7" title="48">{
                        hash = T[int(hash^mess[i])]
                }</span>
                <span class="cov3" title="6">result += uint16(hash) &lt;&lt; (8 * j)</span>
        }
        <span class="cov2" title="3">return result</span>
}

func Harmonic(n int) float64 <span class="cov3" title="6">{
        if n &lt; 0 </span><span class="cov2" title="2">{
                panic("algos.math.Harmonic(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov3" title="4">sum := 0.0
        for i := 1; i &lt;= n; i++ </span><span class="cov10" title="261">{
                sum += 1.0 / float64(i)
        }</span>
        <span class="cov3" title="4">return sum</span>
}

// Newton square root
func Sqrt(c float64) float64 <span class="cov3" title="6">{
        if c &lt; 0 </span><span class="cov2" title="2">{
                panic("algos.math.Sqrt(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov3" title="4">err := 1e-15
        t := c
        for Abs(t-c/t) &gt; (err * t) </span><span class="cov6" title="28">{
                t = (c/t + t) / 2.0
        }</span>
        <span class="cov3" title="4">return t</span>
}

func Abs[T I.Signed | I.Float](val T) T <span class="cov7" title="60">{
        if val &lt; 0 </span><span class="cov3" title="6">{
                return val * (-1)
        }</span> else<span class="cov7" title="54"> {
                return val
        }</span>
}

func IsPrime(n int) bool <span class="cov4" title="9">{
        if n &lt; 2 </span><span class="cov2" title="3">{
                return false
        }</span>
        <span class="cov3" title="6">for i := 2; (i * i) &lt;= n; i++ </span><span class="cov7" title="63">{
                if (n % i) == 0 </span><span class="cov2" title="2">{
                        return false
                }</span>
        }
        <span class="cov3" title="4">return true</span>
}

// Evklid NOD
func Gcd(p, q int) int <span class="cov4" title="10">{
        p, q = Abs(p), Abs(q)
        if q == 0 </span><span class="cov3" title="4">{
                return p
        }</span>
        <span class="cov3" title="6">r := p % q
        return Gcd(q, r)</span>
}

func Min[T I.Ord](x, y T) T <span class="cov4" title="9">{
        if x &lt; y </span><span class="cov3" title="4">{
                return x
        }</span> else<span class="cov3" title="5"> {
                return y
        }</span>
}

func Max[T I.Ord](x, y T) T <span class="cov4" title="9">{
        if x &gt; y </span><span class="cov3" title="4">{
                return x
        }</span> else<span class="cov3" title="5"> {
                return y
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tree

import (
        // amath "github.com/kselnaag/algos/math"
        I "github.com/kselnaag/algos/types"
)

// left-linear red-black tree for mapping
type RBnode[K I.Ord, V any] struct {
        Key   K
        Val   V
        L, R  *RBnode[K, V]
        IsRed bool
}

type RBmap[K I.Ord, V any] struct {
        root *RBnode[K, V]
        size int
}

func (tm *RBmap[K, V]) NewTmap() RBmap[K, V] <span class="cov0" title="0">{
        return RBmap[K, V]{
                root: nil,
                size: 0,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import "fmt"

type Comp interface {
        CompareTo(Comp) int
}

type Ord interface {
        Integer | Float | ~string
}

type Integer interface {
        Signed | Unsigned
}

type Ptr interface {
        ~uintptr
}

type Float interface {
        ~float32 | ~float64
}

type Unsigned interface {
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type Signed interface {
        ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type TestStruct struct {
        A int
        B int
}

func (s TestStruct) CompareTo(obj Comp) int <span class="cov6" title="6">{
        this := s.A + s.B
        that := (obj.(*TestStruct)).A + (obj.(*TestStruct)).B
        if this &lt; that </span><span class="cov4" title="3">{
                return -1
        }</span>
        <span class="cov4" title="3">if this &gt; that </span><span class="cov2" title="2">{
                return +1
        }</span>
        <span class="cov1" title="1">return 0</span>
}

func ConvToByteArr[T Ord](mess T) []byte <span class="cov7" title="11">{
        res := make([]byte, 8)
        switch m := any(mess).(type) </span>{
        case int:<span class="cov4" title="3">
                mi := uint(m)
                for i := 0; i &lt; 8; i++ </span><span class="cov10" title="24">{
                        res[i] = byte(mi &gt;&gt; (8 * (7 - i)))
                }</span>
        case uint:<span class="cov4" title="3">
                for i := 0; i &lt; 8; i++ </span><span class="cov10" title="24">{
                        res[i] = byte(m &gt;&gt; (8 * (7 - i)))
                }</span>
        case float64:<span class="cov4" title="3">
                mi := uint(m)
                for i := 0; i &lt; 8; i++ </span><span class="cov10" title="24">{
                        res[i] = byte(mi &gt;&gt; (8 * (7 - i)))
                }</span>
        case string:<span class="cov1" title="1">
                return []byte(m)</span>
        default:<span class="cov1" title="1">
                s := "algos.(math).ConvToByteArr(mess any): Type of arg is Ord interface, but not processed: "
                s += fmt.Sprintf("arg Type is: %T", mess)
                panic(s)</span>
        }
        <span class="cov7" title="9">return res</span>
}

func LT[T any](i, j T) bool <span class="cov8" title="13">{
        switch ii := any(i).(type) </span>{
        case int:<span class="cov2" title="2">
                jj := any(j).(int)
                return ii &lt; jj</span>
        case float64:<span class="cov2" title="2">
                jj := any(j).(float64)
                return ii &lt; jj</span>
        case string:<span class="cov2" title="2">
                jj := any(j).(string)
                return ii &lt; jj</span>
        case Comp:<span class="cov2" title="2">
                jj := any(j).(Comp)
                return ii.CompareTo(jj) &lt; 0</span>
        case uint:<span class="cov2" title="2">
                jj := any(j).(uint)
                return ii &lt; jj</span>
        case uint32:<span class="cov2" title="2">
                jj := any(j).(uint32)
                return ii &lt; jj</span>
        default:<span class="cov1" title="1">
                s := "algos.(array).equals.lt[T any](i, j T): Type of args is not Ord or Comp interface: "
                s += fmt.Sprintf("arg Type is: %T", i)
                panic(s)</span>
        }
}

func GT[T any](i, j T) bool <span class="cov8" title="13">{
        switch ii := any(i).(type) </span>{
        case int:<span class="cov2" title="2">
                jj := any(j).(int)
                return ii &gt; jj</span>
        case float64:<span class="cov2" title="2">
                jj := any(j).(float64)
                return ii &gt; jj</span>
        case string:<span class="cov2" title="2">
                jj := any(j).(string)
                return ii &gt; jj</span>
        case Comp:<span class="cov2" title="2">
                jj := any(j).(Comp)
                return ii.CompareTo(jj) &gt; 0</span>
        case uint:<span class="cov2" title="2">
                jj := any(j).(uint)
                return ii &gt; jj</span>
        case uint32:<span class="cov2" title="2">
                jj := any(j).(uint32)
                return ii &gt; jj</span>
        default:<span class="cov1" title="1">
                s := "algos.(array).equals.gt[T any](i, j T): Type of args is not Ord or Comp interface: "
                s += fmt.Sprintf("arg Type is: %T", i)
                panic(s)</span>
        }
}

func EQ[T any](i, j T) bool <span class="cov8" title="13">{
        switch ii := any(i).(type) </span>{
        case int:<span class="cov2" title="2">
                jj := any(j).(int)
                return ii == jj</span>
        case float64:<span class="cov2" title="2">
                jj := any(j).(float64)
                return ii == jj</span>
        case string:<span class="cov2" title="2">
                jj := any(j).(string)
                return ii == jj</span>
        case Comp:<span class="cov2" title="2">
                jj := any(j).(Comp)
                return ii.CompareTo(jj) == 0</span>
        case uint:<span class="cov2" title="2">
                jj := any(j).(uint)
                return ii == jj</span>
        case uint32:<span class="cov2" title="2">
                jj := any(j).(uint32)
                return ii == jj</span>
        default:<span class="cov1" title="1">
                s := "algos.(array).equals.eq[T any](i, j T): Type of args is not Ord or Comp interface: "
                s += fmt.Sprintf("arg Type is: %T", i)
                panic(s)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
