
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>array: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kselnaag/algos/array/equal.go (93.3%)</option>
				
				<option value="file1">github.com/kselnaag/algos/array/pqComp.go (0.0%)</option>
				
				<option value="file2">github.com/kselnaag/algos/array/pqOrd.go (96.6%)</option>
				
				<option value="file3">github.com/kselnaag/algos/array/sortComp.go (18.2%)</option>
				
				<option value="file4">github.com/kselnaag/algos/array/sortOrd.go (80.3%)</option>
				
				<option value="file5">github.com/kselnaag/algos/array/stack.go (100.0%)</option>
				
				<option value="file6">github.com/kselnaag/algos/graph/uf.go (95.8%)</option>
				
				<option value="file7">github.com/kselnaag/algos/list/stack.go (98.7%)</option>
				
				<option value="file8">github.com/kselnaag/algos/math/math.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package array

import (
        "math/rand"

        I "github.com/kselnaag/algos/types"
)

func gtOrd[T I.Ord](i, j T) bool <span class="cov8" title="1">{
        return i &gt; j
}</span>

func ltOrd[T I.Ord](i, j T) bool <span class="cov8" title="1">{
        return i &lt; j
}</span>

func eqOrd[T I.Ord](i, j T) bool <span class="cov8" title="1">{
        return i == j
}</span>

func gtComp[T I.Comp](i, j *T) bool <span class="cov8" title="1">{
        return (*i).CompareTo(*j) &gt; 0
}</span>

func ltComp[T I.Comp](i, j *T) bool <span class="cov8" title="1">{
        return (*i).CompareTo(*j) &lt; 0
}</span>

func eqComp[T I.Comp](i, j *T) bool <span class="cov0" title="0">{
        return (*i).CompareTo(*j) == 0
}</span>

func Shuffle[T any](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov8" title="1">{
                j := rand.Intn(i + 1)
                swap(arr, i, j)
        }</span>
}

func Reverse[T any](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov8" title="1">{
                swap(arr, i, alen-i-1)
        }</span>
}

func swap[T any](arr []T, i, j int) <span class="cov8" title="1">{
        arr[i], arr[j] = arr[j], arr[i]
}</span>

/*
func median3Ord[T I.Ord](arr []T, i, j, k int) int {
        if ltOrd(arr, i, j) {
                if ltOrd(arr, j, k) {
                        return j
                } else {
                        if ltOrd(arr, i, k) {
                                return k
                        } else {
                                return i
                        }
                }
        } else {
                if ltOrd(arr, k, j) {
                        return j
                } else {
                        if ltOrd(arr, k, i) {
                                return k
                        } else {
                                return i
                        }
                }
        }
}
*/
</pre>
		
		<pre class="file" id="file1" style="display: none">package array

import (
        I "github.com/kselnaag/algos/types"
)

// ===========================
type MinPQComp[T I.Comp] struct {
        pq   []*T
        size int
}

func NewMinPQComp[T I.Comp]() MinPQComp[T] <span class="cov0" title="0">{
        return MinPQComp[T]{
                pq:   make([]*T, 1, 8),
                size: 0,
        }
}</span>

func (min *MinPQComp[T]) IsEmpty() bool <span class="cov0" title="0">{
        return min.size == 0
}</span>

func (min *MinPQComp[T]) Size() int <span class="cov0" title="0">{
        return min.size
}</span>

func (min *MinPQComp[T]) swim(k int) <span class="cov0" title="0">{
        for (k &gt; 1) &amp;&amp; gtComp(min.pq[k/2], min.pq[k]) </span><span class="cov0" title="0">{
                swap(min.pq, k/2, k)
                k /= 2
        }</span>
}
func (min *MinPQComp[T]) sink(k int) <span class="cov0" title="0">{
        for (2 * k) &lt;= min.size </span><span class="cov0" title="0">{
                j := 2 * k
                if (j &lt; min.size) &amp;&amp; gtComp(min.pq[j], min.pq[j+1]) </span><span class="cov0" title="0">{
                        j++
                }</span>
                <span class="cov0" title="0">if !gtComp(min.pq[k], min.pq[j]) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">swap(min.pq, k, j)
                k = j</span>
        }
}

func (min *MinPQComp[T]) Add(val *T) <span class="cov0" title="0">{
        min.size++
        if len(min.pq) &gt; min.size </span><span class="cov0" title="0">{
                min.pq[min.size] = val
        }</span> else<span class="cov0" title="0"> {
                min.pq = append(min.pq, val)
        }</span>
        <span class="cov0" title="0">min.swim(min.size)</span>
}

func (min *MinPQComp[T]) Min() *T <span class="cov0" title="0">{
        if min.size &lt; 1 </span><span class="cov0" title="0">{
                panic("algos.array.(MinPQ).Min(): Queue is empty ")</span>
        }
        <span class="cov0" title="0">return min.pq[1]</span>
}

func (min *MinPQComp[T]) GetMin() *T <span class="cov0" title="0">{
        if min.size &lt; 1 </span><span class="cov0" title="0">{
                panic("algos.array.(MinPQ).GetMin(): Queue is empty ")</span>
        }
        <span class="cov0" title="0">ret := min.pq[1]
        swap(min.pq, 1, min.size)
        min.size--
        min.sink(1)
        return ret</span>
}

// ===========================
type MaxPQComp[T I.Comp] struct {
        pq   []*T
        size int
}

func NewMaxPQComp[T I.Comp]() MaxPQComp[T] <span class="cov0" title="0">{
        return MaxPQComp[T]{
                pq:   make([]*T, 1, 8),
                size: 0,
        }
}</span>

func (max *MaxPQComp[T]) IsEmpty() bool <span class="cov0" title="0">{
        return max.size == 0
}</span>

func (max *MaxPQComp[T]) Size() int <span class="cov0" title="0">{
        return max.size
}</span>

func (max *MaxPQComp[T]) swim(k int) <span class="cov0" title="0">{
        for (k &gt; 1) &amp;&amp; ltComp(max.pq[k/2], max.pq[k]) </span><span class="cov0" title="0">{
                swap(max.pq, k/2, k)
                k /= 2
        }</span>
}
func (max *MaxPQComp[T]) sink(k int) <span class="cov0" title="0">{
        for (2 * k) &lt;= max.size </span><span class="cov0" title="0">{
                j := 2 * k
                if (j &lt; max.size) &amp;&amp; ltComp(max.pq[j], max.pq[j+1]) </span><span class="cov0" title="0">{
                        j++
                }</span>
                <span class="cov0" title="0">if !ltComp(max.pq[k], max.pq[j]) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">swap(max.pq, k, j)
                k = j</span>
        }
}

func (max *MaxPQComp[T]) Add(val *T) <span class="cov0" title="0">{
        max.size++
        if len(max.pq) &gt; max.size </span><span class="cov0" title="0">{
                max.pq[max.size] = val
        }</span> else<span class="cov0" title="0"> {
                max.pq = append(max.pq, val)
        }</span>
        <span class="cov0" title="0">max.swim(max.size)</span>
}

func (max *MaxPQComp[T]) Max() *T <span class="cov0" title="0">{
        if max.size &lt; 1 </span><span class="cov0" title="0">{
                panic("algos.array.(MaxPQ).Max(): Queue is empty ")</span>
        }
        <span class="cov0" title="0">return max.pq[1]</span>
}

func (max *MaxPQComp[T]) GetMax() *T <span class="cov0" title="0">{
        if max.size &lt; 1 </span><span class="cov0" title="0">{
                panic("algos.array.(MaxPQ).GetMax(): Queue is empty ")</span>
        }
        <span class="cov0" title="0">ret := max.pq[1]
        swap(max.pq, 1, max.size)
        max.size--
        max.sink(1)
        return ret</span>
}

/*
//===========================//
type MinIdxPQComp[T I.Comp] struct {
        pq   []int
        qp   []int
        keys []*T
        size int
}

func NewMinIdxPQComp[T I.Comp]() MinIdxPQComp[T] {
        alen := 1
        acap := 8
        return MinIdxPQComp[T]{
                pq:   make([]int, alen, acap),
                qp:   make([]int, alen, acap),
                keys: make([]*T, alen, acap),
                size: 0,
        }
}

func (min *MinIdxPQComp[T]) gt(i, j int) bool {
        return min.keys[min.pq[i]] &gt; min.keys[min.pq[j]]
}

func (min *MinIdxPQComp[T]) swap(i, j int) {
        min.pq[i], min.pq[j] = min.pq[j], min.pq[i]
        min.qp[min.pq[i]], min.qp[min.pq[j]] = i, j
}

func (min *MinIdxPQComp[T]) swim(k int) {
        for (k &gt; 1) &amp;&amp; min.gt(k/2, k) {
                min.swap(k/2, k)
                k /= 2
        }
}

func (min *MinIdxPQComp[T]) sink(k int) {
        for (2 * k) &lt;= min.size {
                j := 2 * k
                if (j &lt; min.size) &amp;&amp; min.gt(j, j+1) {
                        j++
                }
                if !min.gt(k, j) {
                        break
                }
                min.swap(k, j)
                k = j
        }
}

func (min *MinIdxPQComp[T]) IsEmpty() bool {
        return min.size == 0
}

func (min *MinIdxPQComp[T]) Size() int {
        return min.size
}

func (min *MinIdxPQComp[T]) Contains(k int) bool {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).Contains(k): Index 'k' is out of range")
        }
        return min.qp[k] != 0
}

func (min *MinIdxPQComp[T]) InsertVal(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).InsertVal(k, v): Index 'k' is out of range ")
        }
        if min.Contains(k) {
                panic("algos.array.(MinIdxPQ).InsertVal(k, v): Index 'k' is already exist ")
        }
        min.size++
        if len(min.pq) &gt; min.size {
                min.qp[k] = min.size
                min.pq[min.size] = k
                min.keys[k] = v

        } else {
                min.qp = append(min.qp, min.size)
                min.pq = append(min.pq, k)
                min.keys = append(min.keys, v)
        }
        min.swim(min.size)
}

func (min *MinIdxPQComp[T]) MinIndex() int {
        if min.size &lt; 1 {
                panic("algos.array.(MinIdxPQ).MinIndex(): No Index to return, zero length queqe")
        }
        return min.pq[1]
}

func (min *MinIdxPQComp[T]) MinVal() T {
        if min.size &lt; 1 {
                panic("algos.array.(MinIdxPQ).MinVal(): No Val to return, zero length queqe")
        }
        return min.keys[min.pq[1]]
}

func (min *MinIdxPQComp[T]) DelMinIndex() int {
        if min.size &lt; 1 {
                panic("algos.array.(MinIdxPQ).DelMinIndex(): No val to return, zero lenght queqe")
        }
        ret := min.pq[1]
        min.swap(1, min.size)
        min.size--
        min.sink(1)
        min.qp[ret] = 0
        min.pq[min.size+1] = 0
        return ret
}

func (min *MinIdxPQComp[T]) Val(k int) T {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).Val(k): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).Val(k): Index 'k' is not in queue ")
        }
        return min.keys[k]
}

func (min *MinIdxPQComp[T]) ChangeVal(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).ChangeVal(k, v): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).ChangeVal(k, v): Index 'k' is not in queue ")
        }
        min.keys[k] = v
        min.swim(min.qp[k])
        min.sink(min.qp[k])
}

func (min *MinIdxPQComp[T]) IncreaseIndex(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).IncreaseIndex(k, v): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).IncreaseIndex(k, v): Index 'k' is not in queue ")
        }
        if min.keys[k] &gt;= v {
                panic("algos.array.(MinIdxPQ).IncreaseIndex(k, v): With such index 'k' and value 'v' queue would not change anything ")
        }
        min.keys[k] = v
        min.sink(min.qp[k])
}

func (min *MinIdxPQComp[T]) DecreaseIndex(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).DecreaseIndex(k, v): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).DecreaseIndex(k, v): Index 'k' is not in queue ")
        }
        if min.keys[k] &lt;= v {
                panic("algos.array.(MinIdxPQ).DecreaseIndex(k, v): With such index 'k' and value 'v' queue would not change anything ")
        }
        min.keys[k] = v
        min.swim(min.qp[k])
}

func (min *MinIdxPQComp[T]) DeleteIndex(k int) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).DeleteIndex(k): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).DeleteIndex(k): Index 'k' is not in queue ")
        }
        index := min.qp[k]
        min.swap(index, min.size)
        min.size--
        min.swim(index)
        min.sink(index)
        min.qp[k] = 0
}

// ===========================
type MaxIdxPQComp[T I.Comp] struct {
        pq   []*T
        size int
}

func NewMaxIdxPQComp[T I.Comp]() MaxIdxPQComp[T] {
        return MaxIdxPQComp[T]{
                pq:   make([]*T, 1, 8),
                size: 0,
        }
}

// IsEmpty
// Size
// Insert
// Change
// Contains
// Delete
// MaxVal
// DelMaxIndex
// MaxIndex

*/
</pre>
		
		<pre class="file" id="file2" style="display: none">package array

import (
        I "github.com/kselnaag/algos/types"
)

// ===========================
type MinPQOrd[T I.Ord] struct {
        pq   []T
        size int
}

func NewMinPQOrd[T I.Ord]() MinPQOrd[T] <span class="cov8" title="1">{
        return MinPQOrd[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (min *MinPQOrd[T]) IsEmpty() bool <span class="cov8" title="1">{
        return min.size == 0
}</span>

func (min *MinPQOrd[T]) Size() int <span class="cov8" title="1">{
        return min.size
}</span>

func (min *MinPQOrd[T]) swim(k int) <span class="cov8" title="1">{
        for (k &gt; 1) &amp;&amp; gtOrd(min.pq[k/2], min.pq[k]) </span><span class="cov8" title="1">{
                swap(min.pq, k/2, k)
                k /= 2
        }</span>
}
func (min *MinPQOrd[T]) sink(k int) <span class="cov8" title="1">{
        for (2 * k) &lt;= min.size </span><span class="cov8" title="1">{
                j := 2 * k
                if (j &lt; min.size) &amp;&amp; gtOrd(min.pq[j], min.pq[j+1]) </span><span class="cov8" title="1">{
                        j++
                }</span>
                <span class="cov8" title="1">if !gtOrd(min.pq[k], min.pq[j]) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">swap(min.pq, k, j)
                k = j</span>
        }
}

func (min *MinPQOrd[T]) Add(val T) <span class="cov8" title="1">{
        min.size++
        if len(min.pq) &gt; min.size </span><span class="cov0" title="0">{
                min.pq[min.size] = val
        }</span> else<span class="cov8" title="1"> {
                min.pq = append(min.pq, val)
        }</span>
        <span class="cov8" title="1">min.swim(min.size)</span>
}

func (min *MinPQOrd[T]) Min() T <span class="cov8" title="1">{
        if min.size &lt; 1 </span><span class="cov8" title="1">{
                panic("algos.array.(MinPQ).Min(): Queue is empty ")</span>
        }
        <span class="cov8" title="1">return min.pq[1]</span>
}

func (min *MinPQOrd[T]) GetMin() T <span class="cov8" title="1">{
        if min.size &lt; 1 </span><span class="cov8" title="1">{
                panic("algos.array.(MinPQ).GetMin(): Queue is empty ")</span>
        }
        <span class="cov8" title="1">ret := min.pq[1]
        swap(min.pq, 1, min.size)
        min.size--
        min.sink(1)
        return ret</span>
}

// ===========================
type MaxPQOrd[T I.Ord] struct {
        pq   []T
        size int
}

func NewMaxPQOrd[T I.Ord]() MaxPQOrd[T] <span class="cov8" title="1">{
        return MaxPQOrd[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (max *MaxPQOrd[T]) IsEmpty() bool <span class="cov8" title="1">{
        return max.size == 0
}</span>

func (max *MaxPQOrd[T]) Size() int <span class="cov8" title="1">{
        return max.size
}</span>

func (max *MaxPQOrd[T]) swim(k int) <span class="cov8" title="1">{
        for (k &gt; 1) &amp;&amp; ltOrd(max.pq[k/2], max.pq[k]) </span><span class="cov8" title="1">{
                swap(max.pq, k/2, k)
                k /= 2
        }</span>
}
func (max *MaxPQOrd[T]) sink(k int) <span class="cov8" title="1">{
        for (2 * k) &lt;= max.size </span><span class="cov8" title="1">{
                j := 2 * k
                if (j &lt; max.size) &amp;&amp; ltOrd(max.pq[j], max.pq[j+1]) </span><span class="cov8" title="1">{
                        j++
                }</span>
                <span class="cov8" title="1">if !ltOrd(max.pq[k], max.pq[j]) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">swap(max.pq, k, j)
                k = j</span>
        }
}

func (max *MaxPQOrd[T]) Add(val T) <span class="cov8" title="1">{
        max.size++
        if len(max.pq) &gt; max.size </span><span class="cov0" title="0">{
                max.pq[max.size] = val
        }</span> else<span class="cov8" title="1"> {
                max.pq = append(max.pq, val)
        }</span>
        <span class="cov8" title="1">max.swim(max.size)</span>
}

func (max *MaxPQOrd[T]) Max() T <span class="cov8" title="1">{
        if max.size &lt; 1 </span><span class="cov8" title="1">{
                panic("algos.array.(MaxPQ).Max(): Queue is empty ")</span>
        }
        <span class="cov8" title="1">return max.pq[1]</span>
}

func (max *MaxPQOrd[T]) GetMax() T <span class="cov8" title="1">{
        if max.size &lt; 1 </span><span class="cov8" title="1">{
                panic("algos.array.(MaxPQ).GetMax(): Queue is empty ")</span>
        }
        <span class="cov8" title="1">ret := max.pq[1]
        swap(max.pq, 1, max.size)
        max.size--
        max.sink(1)
        return ret</span>
}

/*
//===========================//
type MinIdxPQOrd[T I.Ord] struct {
        pq   []int
        qp   []int
        keys []T
        size int
}

func NewMinIdxPQOrd[T I.Ord]() MinIdxPQOrd[T] {
        alen := 1
        acap := 8
        return MinIdxPQOrd[T]{
                pq:   make([]int, alen, acap),
                qp:   make([]int, alen, acap),
                keys: make([]T, alen, acap),
                size: 0,
        }
}

func (min *MinIdxPQOrd[T]) gt(i, j int) bool {
        return min.keys[min.pq[i]] &gt; min.keys[min.pq[j]]
}

func (min *MinIdxPQOrd[T]) swap(i, j int) {
        min.pq[i], min.pq[j] = min.pq[j], min.pq[i]
        min.qp[min.pq[i]], min.qp[min.pq[j]] = i, j
}

func (min *MinIdxPQOrd[T]) swim(k int) {
        for (k &gt; 1) &amp;&amp; min.gt(k/2, k) {
                min.swap(k/2, k)
                k /= 2
        }
}

func (min *MinIdxPQOrd[T]) sink(k int) {
        for (2 * k) &lt;= min.size {
                j := 2 * k
                if (j &lt; min.size) &amp;&amp; min.gt(j, j+1) {
                        j++
                }
                if !min.gt(k, j) {
                        break
                }
                min.swap(k, j)
                k = j
        }
}

func (min *MinIdxPQOrd[T]) IsEmpty() bool {
        return min.size == 0
}

func (min *MinIdxPQOrd[T]) Size() int {
        return min.size
}

func (min *MinIdxPQOrd[T]) Contains(k int) bool {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).Contains(k): Index 'k' is out of range")
        }
        return min.qp[k] != 0
}

func (min *MinIdxPQOrd[T]) InsertVal(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).InsertVal(k, v): Index 'k' is out of range ")
        }
        if min.Contains(k) {
                panic("algos.array.(MinIdxPQ).InsertVal(k, v): Index 'k' is already exist ")
        }
        min.size++
        if len(min.pq) &gt; min.size {
                min.qp[k] = min.size
                min.pq[min.size] = k
                min.keys[k] = v

        } else {
                min.qp = append(min.qp, min.size)
                min.pq = append(min.pq, k)
                min.keys = append(min.keys, v)
        }
        min.swim(min.size)
}

func (min *MinIdxPQOrd[T]) MinIndex() int {
        if min.size &lt; 1 {
                panic("algos.array.(MinIdxPQ).MinIndex(): No Index to return, zero length queqe")
        }
        return min.pq[1]
}

func (min *MinIdxPQOrd[T]) MinVal() T {
        if min.size &lt; 1 {
                panic("algos.array.(MinIdxPQ).MinVal(): No Val to return, zero length queqe")
        }
        return min.keys[min.pq[1]]
}

func (min *MinIdxPQOrd[T]) DelMinIndex() int {
        if min.size &lt; 1 {
                panic("algos.array.(MinIdxPQ).DelMinIndex(): No val to return, zero lenght queqe")
        }
        ret := min.pq[1]
        min.swap(1, min.size)
        min.size--
        min.sink(1)
        min.qp[ret] = 0
        min.pq[min.size+1] = 0
        return ret
}

func (min *MinIdxPQOrd[T]) Val(k int) T {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).Val(k): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).Val(k): Index 'k' is not in queue ")
        }
        return min.keys[k]
}

func (min *MinIdxPQOrd[T]) ChangeVal(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).ChangeVal(k, v): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).ChangeVal(k, v): Index 'k' is not in queue ")
        }
        min.keys[k] = v
        min.swim(min.qp[k])
        min.sink(min.qp[k])
}

func (min *MinIdxPQOrd[T]) IncreaseIndex(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).IncreaseIndex(k, v): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).IncreaseIndex(k, v): Index 'k' is not in queue ")
        }
        if min.keys[k] &gt;= v {
                panic("algos.array.(MinIdxPQ).IncreaseIndex(k, v): With such index 'k' and value 'v' queue would not change anything ")
        }
        min.keys[k] = v
        min.sink(min.qp[k])
}

func (min *MinIdxPQOrd[T]) DecreaseIndex(k int, v T) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).DecreaseIndex(k, v): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).DecreaseIndex(k, v): Index 'k' is not in queue ")
        }
        if min.keys[k] &lt;= v {
                panic("algos.array.(MinIdxPQ).DecreaseIndex(k, v): With such index 'k' and value 'v' queue would not change anything ")
        }
        min.keys[k] = v
        min.swim(min.qp[k])
}

func (min *MinIdxPQOrd[T]) DeleteIndex(k int) {
        if (k &lt; 1) || (k &gt; min.size) {
                panic("algos.array.(MinIdxPQ).DeleteIndex(k): Index 'k' is out of range ")
        }
        if !min.Contains(k) {
                panic("algos.array.(MinIdxPQ).DeleteIndex(k): Index 'k' is not in queue ")
        }
        index := min.qp[k]
        min.swap(index, min.size)
        min.size--
        min.swim(index)
        min.sink(index)
        min.qp[k] = 0
}

// ===========================
type MaxIdxPQOrd[T I.Ord] struct {
        pq   []T
        size int
}

func NewMaxIdxPQOrd[T I.Ord]() MaxIdxPQOrd[T] {
        return MaxIdxPQOrd[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}

// IsEmpty
// Size
// Insert
// Change
// Contains
// Delete
// MaxVal
// DelMaxIndex
// MaxIndex

*/
</pre>
		
		<pre class="file" id="file3" style="display: none">package array

import I "github.com/kselnaag/algos/types"

func HeapSortComp[T I.Comp](arr []*T) <span class="cov0" title="0">{
        alen := len(arr)
        for k := alen / 2; k &gt; 0; k-- </span><span class="cov0" title="0">{
                sinkComp(arr, k, alen-1)
        }</span>
        <span class="cov0" title="0">for n := alen - 1; n &gt; 1; </span><span class="cov0" title="0">{
                swap(arr, 1, n)
                n--
                sinkComp(arr, 1, n)
        }</span>
}

func sinkComp[T I.Comp](arr []*T, k, n int) <span class="cov0" title="0">{
        for (2 * k) &lt;= n </span><span class="cov0" title="0">{
                j := 2 * k
                if (j &lt; n) &amp;&amp; ltComp(arr[j], arr[j+1]) </span><span class="cov0" title="0">{
                        j++
                }</span>
                <span class="cov0" title="0">if !ltComp(arr[k], arr[j]) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">swap(arr, k, j)
                k = j</span>
        }
}

func QuickSortComp[T I.Comp](arr []*T) <span class="cov0" title="0">{
        Shuffle(arr)
        qsortComp(arr, 0, len(arr)-1)
}</span>

func qsortComp[T I.Comp](arr []*T, lo, hi int) <span class="cov0" title="0">{
        if hi &lt;= lo </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if (hi - lo + 1) &lt;= 12 </span><span class="cov0" title="0">{
                InsertSortComp(arr)
                return
        }</span>
        <span class="cov0" title="0">j := pivotComp(arr, lo, hi)
        qsortComp(arr, lo, j-1)
        qsortComp(arr, j+1, hi)</span>
}

func pivotComp[T I.Comp](arr []*T, lo, hi int) int <span class="cov0" title="0">{
        i, j, v := lo, hi, lo
        for </span><span class="cov0" title="0">{
                for ; ltComp(arr[i], arr[v]); i++ </span><span class="cov0" title="0">{
                        if i == hi </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">for ; ltComp(arr[v], arr[j]); j-- </span><span class="cov0" title="0">{
                        if j == lo </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if i &gt;= j </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">swap(arr, i, j)</span>
        }
        <span class="cov0" title="0">swap(arr, lo, j)
        return j</span>
}

func MergeSortComp[T I.Comp](arr []*T) <span class="cov0" title="0">{
        alen := len(arr)
        aux := make([]*T, alen)
        copy(aux, arr)
        mrgsortComp(aux, arr, 0, alen-1)
}</span>

func mrgsortComp[T I.Comp](src []*T, dst []*T, lo, hi int) <span class="cov0" title="0">{
        if hi &lt;= lo </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if (hi - lo + 1) &lt;= 12 </span><span class="cov0" title="0">{
                InsertSortComp(src[lo : hi+1])
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov0" title="0">mid := lo + (hi-lo)/2
        mrgsortComp(dst, src, lo, mid)
        mrgsortComp(dst, src, mid+1, hi)
        mergeComp(src, dst, lo, mid, hi)</span>
}

func mergeComp[T I.Comp](src []*T, dst []*T, lo, mid, hi int) <span class="cov0" title="0">{
        if !gtComp(src[mid], src[mid+1]) </span><span class="cov0" title="0">{
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov0" title="0">i, j := lo, mid+1
        for k := lo; k &lt;= hi; k++ </span><span class="cov0" title="0">{
                if i &gt; mid </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                        continue</span>
                }
                <span class="cov0" title="0">if j &gt; hi </span><span class="cov0" title="0">{
                        dst[k] = src[i]
                        i++
                        continue</span>
                }
                <span class="cov0" title="0">if ltComp(src[j], src[i]) </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                }</span> else<span class="cov0" title="0"> {
                        dst[k] = src[i]
                        i++
                }</span>
        }
}

func ReverseSortComp[T I.Comp](arr []*T) <span class="cov8" title="1">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov8" title="1">{
                min := i
                max := i
                for j := i + 1; j &lt; (alen - i); j++ </span><span class="cov8" title="1">{
                        if ltComp(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                        <span class="cov8" title="1">if gtComp(arr[j], arr[max]) </span><span class="cov8" title="1">{
                                max = j
                        }</span>
                }
                <span class="cov8" title="1">if max == i </span><span class="cov0" title="0">{
                        if min == (alen - i - 1) </span><span class="cov0" title="0">{
                                swap(arr, max, min)
                        }</span> else<span class="cov0" title="0"> {
                                swap(arr, (alen - i - 1), max)
                                swap(arr, i, min)
                        }</span>
                } else<span class="cov8" title="1"> {
                        swap(arr, i, min)
                        swap(arr, (alen - i - 1), max)
                }</span>
        }
}

func SelectSortComp[T I.Comp](arr []*T) <span class="cov8" title="1">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov8" title="1">{
                min := i
                for j := i + 1; j &lt; alen; j++ </span><span class="cov8" title="1">{
                        if ltComp(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                }
                <span class="cov8" title="1">swap(arr, i, min)</span>
        }
}

func ShellSortComp[T I.Comp](arr []*T) <span class="cov0" title="0">{
        alen := len(arr)
        h := 1
        for h &lt; (alen / 3) </span><span class="cov0" title="0">{
                h = 3*h + 1
        }</span>
        <span class="cov0" title="0">for h &gt; 0 </span><span class="cov0" title="0">{
                for i := h; i &lt; alen; i++ </span><span class="cov0" title="0">{
                        for j := i; j &gt;= h; j -= h </span><span class="cov0" title="0">{
                                if ltComp(arr[j], arr[j-h]) </span><span class="cov0" title="0">{
                                        swap(arr, j, j-h)
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                        }
                }
                <span class="cov0" title="0">h = h / 3</span>
        }
}

func InsertSortComp[T I.Comp](arr []*T) <span class="cov8" title="1">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov8" title="1">{
                for j := i; j &gt; 0; j-- </span><span class="cov8" title="1">{
                        if ltComp(arr[j], arr[j-1]) </span><span class="cov8" title="1">{
                                swap(arr, j, j-1)
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
        }
}

func BinarySearchComp[T I.Comp](arr []*T, elem *T) int <span class="cov0" title="0">{
        low := 0
        high := len(arr)
        for low &lt; high </span><span class="cov0" title="0">{
                mid := (low + ((high - low) / 2))
                val := arr[mid]
                if eqComp(val, elem) </span><span class="cov0" title="0">{
                        return mid
                }</span> else<span class="cov0" title="0"> if gtComp(val, elem) </span><span class="cov0" title="0">{
                        high = mid
                }</span> else<span class="cov0" title="0"> if ltComp(val, elem) </span><span class="cov0" title="0">{
                        low = mid + 1
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func ContainedComp[T I.Comp](arr []*T, elem *T) int <span class="cov0" title="0">{
        for i, el := range arr </span><span class="cov0" title="0">{
                if eqComp(el, elem) </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func IsSortedComp[T I.Comp](arr []*T) bool <span class="cov0" title="0">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov0" title="0">{
                if ltComp(arr[i], arr[i-1]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package array

import I "github.com/kselnaag/algos/types"

func HeapSortOrd[T I.Ord](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        for k := alen / 2; k &gt; 0; k-- </span><span class="cov8" title="1">{
                sinkOrd(arr, k, alen-1)
        }</span>
        <span class="cov8" title="1">for n := alen - 1; n &gt; 1; </span><span class="cov8" title="1">{
                swap(arr, 1, n)
                n--
                sinkOrd(arr, 1, n)
        }</span>
}

func sinkOrd[T I.Ord](arr []T, k, n int) <span class="cov8" title="1">{
        for (2 * k) &lt;= n </span><span class="cov8" title="1">{
                j := 2 * k
                if (j &lt; n) &amp;&amp; ltOrd(arr[j], arr[j+1]) </span><span class="cov8" title="1">{
                        j++
                }</span>
                <span class="cov8" title="1">if !ltOrd(arr[k], arr[j]) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">swap(arr, k, j)
                k = j</span>
        }
}

func QuickSortOrd[T I.Ord](arr []T) <span class="cov8" title="1">{
        Shuffle(arr)
        qsortOrd(arr, 0, len(arr)-1)
}</span>

func qsortOrd[T I.Ord](arr []T, lo, hi int) <span class="cov8" title="1">{
        if hi &lt;= lo </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if (hi - lo + 1) &lt;= 12 </span><span class="cov8" title="1">{
                InsertSortOrd(arr)
                return
        }</span>
        <span class="cov8" title="1">j := pivotOrd(arr, lo, hi)
        qsortOrd(arr, lo, j-1)
        qsortOrd(arr, j+1, hi)</span>
}

func pivotOrd[T I.Ord](arr []T, lo, hi int) int <span class="cov8" title="1">{
        i, j, v := lo, hi, lo
        for </span><span class="cov8" title="1">{
                for ; ltOrd(arr[i], arr[v]); i++ </span><span class="cov0" title="0">{
                        if i == hi </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">for ; ltOrd(arr[v], arr[j]); j-- </span><span class="cov8" title="1">{
                        if j == lo </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">if i &gt;= j </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">swap(arr, i, j)</span>
        }
        <span class="cov8" title="1">swap(arr, lo, j)
        return j</span>
}

func MergeSortOrd[T I.Ord](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        aux := make([]T, alen)
        copy(aux, arr)
        mrgsortOrd(aux, arr, 0, alen-1)
}</span>

func mrgsortOrd[T I.Ord](src []T, dst []T, lo, hi int) <span class="cov8" title="1">{
        if hi &lt;= lo </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if (hi - lo + 1) &lt;= 12 </span><span class="cov8" title="1">{
                InsertSortOrd(src[lo : hi+1])
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov8" title="1">mid := lo + (hi-lo)/2
        mrgsortOrd(dst, src, lo, mid)
        mrgsortOrd(dst, src, mid+1, hi)
        mergeOrd(src, dst, lo, mid, hi)</span>
}

func mergeOrd[T I.Ord](src []T, dst []T, lo, mid, hi int) <span class="cov8" title="1">{
        if !gtOrd(src[mid], src[mid+1]) </span><span class="cov8" title="1">{
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov0" title="0">i, j := lo, mid+1
        for k := lo; k &lt;= hi; k++ </span><span class="cov0" title="0">{
                if i &gt; mid </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                        continue</span>
                }
                <span class="cov0" title="0">if j &gt; hi </span><span class="cov0" title="0">{
                        dst[k] = src[i]
                        i++
                        continue</span>
                }
                <span class="cov0" title="0">if ltOrd(src[j], src[i]) </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                }</span> else<span class="cov0" title="0"> {
                        dst[k] = src[i]
                        i++
                }</span>
        }
}

func ReverseSortOrd[T I.Ord](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov8" title="1">{
                min := i
                max := i
                for j := i + 1; j &lt; (alen - i); j++ </span><span class="cov8" title="1">{
                        if ltOrd(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                        <span class="cov8" title="1">if gtOrd(arr[j], arr[max]) </span><span class="cov8" title="1">{
                                max = j
                        }</span>
                }
                <span class="cov8" title="1">if max == i </span><span class="cov0" title="0">{
                        if min == (alen - i - 1) </span><span class="cov0" title="0">{
                                swap(arr, max, min)
                        }</span> else<span class="cov0" title="0"> {
                                swap(arr, (alen - i - 1), max)
                                swap(arr, i, min)
                        }</span>
                } else<span class="cov8" title="1"> {
                        swap(arr, i, min)
                        swap(arr, (alen - i - 1), max)
                }</span>
        }
}

func SelectSortOrd[T I.Ord](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov8" title="1">{
                min := i
                for j := i + 1; j &lt; alen; j++ </span><span class="cov8" title="1">{
                        if ltOrd(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                }
                <span class="cov8" title="1">swap(arr, i, min)</span>
        }
}

func ShellSortOrd[T I.Ord](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        h := 1
        for h &lt; (alen / 3) </span><span class="cov8" title="1">{
                h = 3*h + 1
        }</span>
        <span class="cov8" title="1">for h &gt; 0 </span><span class="cov8" title="1">{
                for i := h; i &lt; alen; i++ </span><span class="cov8" title="1">{
                        for j := i; j &gt;= h; j -= h </span><span class="cov8" title="1">{
                                if ltOrd(arr[j], arr[j-h]) </span><span class="cov0" title="0">{
                                        swap(arr, j, j-h)
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">h = h / 3</span>
        }
}

func InsertSortOrd[T I.Ord](arr []T) <span class="cov8" title="1">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov8" title="1">{
                for j := i; j &gt; 0; j-- </span><span class="cov8" title="1">{
                        if ltOrd(arr[j], arr[j-1]) </span><span class="cov8" title="1">{
                                swap(arr, j, j-1)
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
        }
}

func BinarySearchOrd[T I.Ord](arr []T, elem T) int <span class="cov8" title="1">{
        low := 0
        high := len(arr)
        for low &lt; high </span><span class="cov8" title="1">{
                mid := (low + ((high - low) / 2))
                val := arr[mid]
                if eqOrd(val, elem) </span><span class="cov8" title="1">{
                        return mid
                }</span> else<span class="cov8" title="1"> if gtOrd(val, elem) </span><span class="cov8" title="1">{
                        high = mid
                }</span> else<span class="cov8" title="1"> if ltOrd(val, elem) </span><span class="cov8" title="1">{
                        low = mid + 1
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func ContainedOrd[T I.Ord](arr []T, elem T) int <span class="cov8" title="1">{
        for i, el := range arr </span><span class="cov8" title="1">{
                if eqOrd(el, elem) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func IsSortedOrd[T I.Ord](arr []T) bool <span class="cov8" title="1">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov8" title="1">{
                if ltOrd(arr[i], arr[i-1]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package array

import (
        _ "github.com/kselnaag/algos/types"
)

// ===========================
type Bag[T any] struct {
        arr  []T
        size int
        fwd  int
}

func NewBag[T any]() Bag[T] <span class="cov8" title="1">{
        return Bag[T]{
                arr:  make([]T, 0, 8),
                size: 0,
                fwd:  -1,
        }
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov8" title="1">{
        return b.size == 0
}</span>

func (b *Bag[T]) Size() int <span class="cov8" title="1">{
        return b.size
}</span>

func (b *Bag[T]) Add(val T) <span class="cov8" title="1">{
        b.arr = append(b.arr, val)
        b.size++
        b.fwd = -1
}</span>

func (b *Bag[T]) Next() T <span class="cov8" title="1">{
        b.fwd++
        if b.fwd == b.size </span><span class="cov8" title="1">{
                b.fwd = 0
        }</span>
        <span class="cov8" title="1">return b.arr[b.fwd]</span>
}

func (b *Bag[T]) Reverse() <span class="cov8" title="1">{
        Reverse(b.arr)
        b.fwd = -1
}</span>

func (b *Bag[T]) Drop() <span class="cov8" title="1">{
        b.arr = b.arr[:0]
        b.fwd = -1
        b.size = 0
}</span>

// ===========================
type Stack[T any] struct {
        arr  []T
        size int
        fwd  int
}

func NewStack[T any]() Stack[T] <span class="cov8" title="1">{
        return Stack[T]{
                arr:  make([]T, 0, 8),
                size: 0,
                fwd:  -1,
        }
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov8" title="1">{
        return s.size == 0
}</span>

func (s *Stack[T]) Size() int <span class="cov8" title="1">{
        return s.size
}</span>

func (s *Stack[T]) Push(val T) <span class="cov8" title="1">{
        s.arr = append(s.arr, val)
        s.size++
        s.fwd = -1
}</span>

func (s *Stack[T]) Pop() T <span class="cov8" title="1">{
        last := len(s.arr) - 1
        ret := s.arr[last]
        s.arr = s.arr[:last]
        s.size--
        s.fwd = -1
        return ret
}</span>

func (s *Stack[T]) Next() T <span class="cov8" title="1">{
        s.fwd++
        if s.fwd == s.size </span><span class="cov8" title="1">{
                s.fwd = 0
        }</span>
        <span class="cov8" title="1">return s.arr[s.fwd]</span>
}

func (s *Stack[T]) Reverse() <span class="cov8" title="1">{
        Reverse(s.arr)
        s.fwd = -1
}</span>

func (s *Stack[T]) Drop() <span class="cov8" title="1">{
        s.arr = s.arr[:0]
        s.fwd = -1
        s.size = 0
}</span>

// ===========================
type Queue[T any] struct {
        arr  []T
        size int
        fwd  int
}

func NewQueue[T any]() Queue[T] <span class="cov8" title="1">{
        return Queue[T]{
                arr:  make([]T, 0, 8),
                size: 0,
                fwd:  -1,
        }
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov8" title="1">{
        return q.size == 0
}</span>

func (q *Queue[T]) Size() int <span class="cov8" title="1">{
        return q.size
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov8" title="1">{
        q.arr = append(q.arr, val)
        q.size++
        q.fwd = -1
}</span>

func (q *Queue[T]) Deq() T <span class="cov8" title="1">{
        ret := q.arr[0]
        q.arr = q.arr[1:]
        q.size--
        q.fwd = -1
        return ret
}</span>

func (q *Queue[T]) Next() T <span class="cov8" title="1">{
        q.fwd++
        if q.fwd == q.size </span><span class="cov8" title="1">{
                q.fwd = 0
        }</span>
        <span class="cov8" title="1">return q.arr[q.fwd]</span>
}

func (q *Queue[T]) Reverse() <span class="cov8" title="1">{
        Reverse(q.arr)
        q.fwd = -1
}</span>

func (q *Queue[T]) Drop() <span class="cov8" title="1">{
        q.arr = q.arr[:0]
        q.fwd = -1
        q.size = 0
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package graph

import (
        "github.com/kselnaag/algos/array"
        "github.com/kselnaag/algos/math"
)

type UF struct {
        id    []int
        bag   array.Bag[int]
        count int
        size  int
}

func NewUF(n int) UF <span class="cov8" title="1">{
        n = math.Abs(n)
        arr := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                arr[i] = i
        }</span>
        <span class="cov8" title="1">return UF{
                id:    arr,
                bag:   array.NewBag[int](),
                count: n,
                size:  n,
        }</span>
}

func (uf *UF) Union(p, q int) <span class="cov8" title="1">{
        pRoot := uf.Find(p)
        qRoot := uf.Find(q)
        if pRoot == qRoot </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">uf.id[qRoot] = pRoot
        uf.count--</span>
}

func (uf *UF) Find(p int) int <span class="cov8" title="1">{
        p = math.Abs(p)
        for p != uf.id[p] </span><span class="cov8" title="1">{
                uf.bag.Add(p)
                p = uf.id[p]
        }</span>
        // path compression
        <span class="cov8" title="1">blen := uf.bag.Size()
        for i := 0; i &lt; blen; i++ </span><span class="cov8" title="1">{
                t := uf.bag.Next()
                uf.id[t] = p
        }</span>
        <span class="cov8" title="1">uf.bag.Drop()
        return p</span>
}

func (uf *UF) Connected(p, q int) bool <span class="cov8" title="1">{
        return uf.Find(p) == uf.Find(q)
}</span>

func (uf *UF) Count() int <span class="cov8" title="1">{
        return uf.count
}</span>

func (uf *UF) Size() int <span class="cov8" title="1">{
        return uf.size
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package list

type node[T any] struct {
        val  T
        next *node[T]
}

func Reverse[T any](first *node[T]) *node[T] <span class="cov8" title="1">{
        if first == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if first.next == nil </span><span class="cov8" title="1">{
                return first
        }</span>
        <span class="cov8" title="1">second := first.next
        root := Reverse(second)
        second.next = first
        first.next = nil
        return root</span>
}

// ===========================
type Bag[T any] struct {
        first *node[T]
        size  int
        fwd   *node[T]
}

func NewBag[T any]() Bag[T] <span class="cov8" title="1">{
        return Bag[T]{
                first: nil,
                size:  0,
                fwd:   nil,
        }
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov8" title="1">{
        return b.size == 0
}</span>

func (b *Bag[T]) Size() int <span class="cov8" title="1">{
        return b.size
}</span>

func (b *Bag[T]) Add(val T) <span class="cov8" title="1">{
        first := b.first
        b.first = &amp;node[T]{val: val, next: first}
        b.size++
        b.fwd = b.first
}</span>

func (b *Bag[T]) Next() T <span class="cov8" title="1">{
        ret := b.fwd.val
        if b.fwd.next == nil </span><span class="cov8" title="1">{
                b.fwd = b.first
        }</span> else<span class="cov8" title="1"> {
                b.fwd = b.fwd.next
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (b *Bag[T]) Reverse() <span class="cov8" title="1">{
        b.fwd = Reverse(b.first)
        b.first = b.fwd
}</span>

func (b *Bag[T]) Drop() <span class="cov8" title="1">{
        b.first = nil
        b.size = 0
        b.fwd = nil
}</span>

// ===========================
type Stack[T any] struct {
        first *node[T]
        size  int
        fwd   *node[T]
}

func NewStack[T any]() Stack[T] <span class="cov8" title="1">{
        return Stack[T]{
                first: nil,
                size:  0,
                fwd:   nil,
        }
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov8" title="1">{
        return s.size == 0
}</span>

func (s *Stack[T]) Size() int <span class="cov8" title="1">{
        return s.size
}</span>

func (s *Stack[T]) Push(val T) <span class="cov8" title="1">{
        first := s.first
        s.first = &amp;node[T]{val: val, next: first}
        s.size++
        s.fwd = s.first
}</span>

func (s *Stack[T]) Pop() T <span class="cov8" title="1">{
        ret := s.first.val
        s.first = s.first.next
        s.size--
        s.fwd = s.first
        return ret
}</span>

func (s *Stack[T]) Next() T <span class="cov8" title="1">{
        ret := s.fwd.val
        if s.fwd.next == nil </span><span class="cov8" title="1">{
                s.fwd = s.first
        }</span> else<span class="cov8" title="1"> {
                s.fwd = s.fwd.next
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (s *Stack[T]) Reverse() <span class="cov8" title="1">{
        s.fwd = Reverse(s.first)
        s.first = s.fwd
}</span>
func (s *Stack[T]) Drop() <span class="cov8" title="1">{
        s.first = nil
        s.size = 0
        s.fwd = nil
}</span>

// ===========================
type Queue[T any] struct {
        first *node[T]
        last  *node[T]
        size  int
        fwd   *node[T]
}

func NewQueue[T any]() Queue[T] <span class="cov8" title="1">{
        return Queue[T]{
                first: nil,
                last:  nil,
                size:  0,
                fwd:   nil,
        }
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov8" title="1">{
        return q.size == 0
}</span>

func (q *Queue[T]) Size() int <span class="cov8" title="1">{
        return q.size
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov8" title="1">{
        newnode := &amp;node[T]{val: val, next: nil}
        if q.size == 0 </span><span class="cov8" title="1">{
                q.first = newnode
        }</span> else<span class="cov8" title="1"> {
                q.last.next = newnode
        }</span>
        <span class="cov8" title="1">q.last = newnode
        q.size++
        q.fwd = q.first</span>
}

func (q *Queue[T]) Deq() T <span class="cov8" title="1">{
        ret := q.first.val
        q.first = q.first.next
        q.size--
        if (q.size == 0) || (q.size == 1) </span><span class="cov8" title="1">{
                q.last = q.first
        }</span>
        <span class="cov8" title="1">q.fwd = q.first
        return ret</span>
}

func (q *Queue[T]) Next() T <span class="cov8" title="1">{
        ret := q.fwd.val
        if q.fwd.next == nil </span><span class="cov8" title="1">{
                q.fwd = q.first
        }</span> else<span class="cov8" title="1"> {
                q.fwd = q.fwd.next
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (q *Queue[T]) Reverse() <span class="cov8" title="1">{
        q.last = q.first
        q.fwd = Reverse(q.first)
        q.first = q.fwd
}</span>

func (q *Queue[T]) Drop() <span class="cov8" title="1">{
        q.first = nil
        q.size = 0
        q.fwd = nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package math

import (
        I "github.com/kselnaag/algos/types"
)

func Harmonic(n int) float64 <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov8" title="1">{
                panic("algos.math.Harmonic(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov8" title="1">sum := 0.0
        for i := 1; i &lt;= n; i++ </span><span class="cov8" title="1">{
                sum += 1.0 / float64(i)
        }</span>
        <span class="cov8" title="1">return sum</span>
}

// Newton square root
func Sqrt(c float64) float64 <span class="cov8" title="1">{
        if c &lt; 0 </span><span class="cov8" title="1">{
                panic("algos.math.Sqrt(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov8" title="1">err := 1e-15
        t := c
        for Abs(t-c/t) &gt; (err * t) </span><span class="cov8" title="1">{
                t = (c/t + t) / 2.0
        }</span>
        <span class="cov8" title="1">return t</span>
}

func Abs[T I.Signed | I.Float](val T) T <span class="cov8" title="1">{
        if val &lt; 0 </span><span class="cov8" title="1">{
                return val * (-1)
        }</span> else<span class="cov8" title="1"> {
                return val
        }</span>
}

func IsPrime(n int) bool <span class="cov8" title="1">{
        if n &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := 2; (i * i) &lt;= n; i++ </span><span class="cov8" title="1">{
                if (n % i) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Evklid NOD
func Gcd(p, q int) int <span class="cov8" title="1">{
        p, q = Abs(p), Abs(q)
        if q == 0 </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">r := p % q
        return Gcd(q, r)</span>
}

func Min[T I.Ord](x, y T) T <span class="cov8" title="1">{
        if x &lt; y </span><span class="cov8" title="1">{
                return x
        }</span> else<span class="cov8" title="1"> {
                return y
        }</span>
}

func Max[T I.Ord](x, y T) T <span class="cov8" title="1">{
        if x &gt; y </span><span class="cov8" title="1">{
                return x
        }</span> else<span class="cov8" title="1"> {
                return y
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
