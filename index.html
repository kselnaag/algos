
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>array: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kselnaag/algos/array/equal.go (50.0%)</option>
				
				<option value="file1">github.com/kselnaag/algos/array/pq.go (96.6%)</option>
				
				<option value="file2">github.com/kselnaag/algos/array/sort.go (81.6%)</option>
				
				<option value="file3">github.com/kselnaag/algos/array/stack.go (100.0%)</option>
				
				<option value="file4">github.com/kselnaag/algos/graph/uf.go (95.8%)</option>
				
				<option value="file5">github.com/kselnaag/algos/list/stack.go (98.7%)</option>
				
				<option value="file6">github.com/kselnaag/algos/math/math.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package array

import (
        "fmt"

        I "github.com/kselnaag/algos/types"
)

func lt[T any](i, j T) bool <span class="cov10" title="6485">{
        switch ii := any(i).(type) </span>{
        case I.Comp:<span class="cov6" title="196">
                jj := any(j).(I.Comp)
                return ii.CompareTo(jj) &lt; 0</span>
        case int:<span class="cov8" title="2089">
                jj := any(j).(int)
                return ii &lt; jj</span>
        case uint:<span class="cov0" title="0">
                jj := any(j).(uint)
                return ii &lt; jj</span>
        case float64:<span class="cov8" title="2118">
                jj := any(j).(float64)
                return ii &lt; jj</span>
        case string:<span class="cov8" title="2082">
                jj := any(j).(string)
                return ii &lt; jj</span>
        default:<span class="cov0" title="0">
                s := "algos.(array).equals.lt[T any](i, j T): Type of args is not Ord or Comp interface: "
                s += fmt.Sprintf("arg Type is: %T", i)
                panic(s)</span>
        }
}

func gt[T any](i, j T) bool <span class="cov7" title="712">{
        switch ii := any(i).(type) </span>{
        case I.Comp:<span class="cov4" title="32">
                jj := any(j).(I.Comp)
                return ii.CompareTo(jj) &gt; 0</span>
        case int:<span class="cov6" title="230">
                jj := any(j).(int)
                return ii &gt; jj</span>
        case uint:<span class="cov0" title="0">
                jj := any(j).(uint)
                return ii &gt; jj</span>
        case float64:<span class="cov6" title="225">
                jj := any(j).(float64)
                return ii &gt; jj</span>
        case string:<span class="cov6" title="225">
                jj := any(j).(string)
                return ii &gt; jj</span>
        default:<span class="cov0" title="0">
                s := "algos.(array).equals.gt[T any](i, j T): Type of args is not Ord or Comp interface: "
                s += fmt.Sprintf("arg Type is: %T", i)
                panic(s)</span>
        }
}

func eq[T any](i, j T) bool <span class="cov3" title="11">{
        switch ii := any(i).(type) </span>{
        case I.Comp:<span class="cov0" title="0">
                jj := any(j).(I.Comp)
                return ii.CompareTo(jj) == 0</span>
        case int:<span class="cov3" title="11">
                jj := any(j).(int)
                return ii == jj</span>
        case uint:<span class="cov0" title="0">
                jj := any(j).(uint)
                return ii == jj</span>
        case float64:<span class="cov0" title="0">
                jj := any(j).(float64)
                return ii == jj</span>
        case string:<span class="cov0" title="0">
                jj := any(j).(string)
                return ii == jj</span>
        default:<span class="cov0" title="0">
                s := "algos.(array).equals.eq[T any](i, j T): Type of args is not Ord or Comp interface: "
                s += fmt.Sprintf("arg Type is: %T", i)
                panic(s)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package array

// ===========================
type MinPQ[T any] struct {
        pq   []T
        size int
}

func NewMinPQ[T any]() MinPQ[T] <span class="cov4" title="3">{
        return MinPQ[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (min *MinPQ[T]) IsEmpty() bool <span class="cov8" title="12">{
        return min.size == 0
}</span>

func (min *MinPQ[T]) Size() int <span class="cov8" title="12">{
        return min.size
}</span>

func (min *MinPQ[T]) swim(k int) <span class="cov9" title="21">{
        for (k &gt; 1) &amp;&amp; gt(min.pq[k/2], min.pq[k]) </span><span class="cov9" title="18">{
                swap(min.pq, k/2, k)
                k /= 2
        }</span>
}
func (min *MinPQ[T]) sink(k int) <span class="cov9" title="21">{
        for (2 * k) &lt;= min.size </span><span class="cov9" title="21">{
                j := 2 * k
                if (j &lt; min.size) &amp;&amp; gt(min.pq[j], min.pq[j+1]) </span><span class="cov6" title="6">{
                        j++
                }</span>
                <span class="cov9" title="21">if !gt(min.pq[k], min.pq[j]) </span><span class="cov7" title="9">{
                        break</span>
                }
                <span class="cov8" title="12">swap(min.pq, k, j)
                k = j</span>
        }
}

func (min *MinPQ[T]) Add(val T) <span class="cov9" title="21">{
        min.size++
        if len(min.pq) &gt; min.size </span><span class="cov0" title="0">{
                min.pq[min.size] = val
        }</span> else<span class="cov9" title="21"> {
                min.pq = append(min.pq, val)
        }</span>
        <span class="cov9" title="21">min.swim(min.size)</span>
}

func (min *MinPQ[T]) Min() T <span class="cov7" title="9">{
        if min.size &lt; 1 </span><span class="cov4" title="3">{
                panic("algos.array.(MinPQ).Min(): Queue is empty ")</span>
        }
        <span class="cov6" title="6">return min.pq[1]</span>
}

func (min *MinPQ[T]) GetMin() T <span class="cov10" title="24">{
        if min.size &lt; 1 </span><span class="cov4" title="3">{
                panic("algos.array.(MinPQ).GetMin(): Queue is empty ")</span>
        }
        <span class="cov9" title="21">ret := min.pq[1]
        swap(min.pq, 1, min.size)
        min.size--
        min.sink(1)
        return ret</span>
}

// ===========================
type MaxPQ[T any] struct {
        pq   []T
        size int
}

func NewMaxPQ[T any]() MaxPQ[T] <span class="cov4" title="3">{
        return MaxPQ[T]{
                pq:   make([]T, 1, 8),
                size: 0,
        }
}</span>

func (max *MaxPQ[T]) IsEmpty() bool <span class="cov8" title="12">{
        return max.size == 0
}</span>

func (max *MaxPQ[T]) Size() int <span class="cov8" title="12">{
        return max.size
}</span>

func (max *MaxPQ[T]) swim(k int) <span class="cov9" title="21">{
        for (k &gt; 1) &amp;&amp; lt(max.pq[k/2], max.pq[k]) </span><span class="cov4" title="3">{
                swap(max.pq, k/2, k)
                k /= 2
        }</span>
}
func (max *MaxPQ[T]) sink(k int) <span class="cov9" title="21">{
        for (2 * k) &lt;= max.size </span><span class="cov10" title="24">{
                j := 2 * k
                if (j &lt; max.size) &amp;&amp; lt(max.pq[j], max.pq[j+1]) </span><span class="cov6" title="6">{
                        j++
                }</span>
                <span class="cov10" title="24">if !lt(max.pq[k], max.pq[j]) </span><span class="cov6" title="6">{
                        break</span>
                }
                <span class="cov9" title="18">swap(max.pq, k, j)
                k = j</span>
        }
}

func (max *MaxPQ[T]) Add(val T) <span class="cov9" title="21">{
        max.size++
        if len(max.pq) &gt; max.size </span><span class="cov0" title="0">{
                max.pq[max.size] = val
        }</span> else<span class="cov9" title="21"> {
                max.pq = append(max.pq, val)
        }</span>
        <span class="cov9" title="21">max.swim(max.size)</span>
}

func (max *MaxPQ[T]) Max() T <span class="cov7" title="9">{
        if max.size &lt; 1 </span><span class="cov4" title="3">{
                panic("algos.array.(MaxPQ).Max(): Queue is empty ")</span>
        }
        <span class="cov6" title="6">return max.pq[1]</span>
}

func (max *MaxPQ[T]) GetMax() T <span class="cov10" title="24">{
        if max.size &lt; 1 </span><span class="cov4" title="3">{
                panic("algos.array.(MaxPQ).GetMax(): Queue is empty ")</span>
        }
        <span class="cov9" title="21">ret := max.pq[1]
        swap(max.pq, 1, max.size)
        max.size--
        max.sink(1)
        return ret</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package array

import (
        "math/rand"
)

func HeapSort[T any](arr []T) <span class="cov5" title="33">{
        alen := len(arr)
        for k := alen / 2; k &gt; 0; k-- </span><span class="cov5" title="75">{
                sink(arr, k, alen-1)
        }</span>
        <span class="cov5" title="33">for n := alen - 1; n &gt; 1; </span><span class="cov6" title="114">{
                swap(arr, 1, n)
                n--
                sink(arr, 1, n)
        }</span>
}

func sink[T any](arr []T, k, n int) <span class="cov7" title="189">{
        for (2 * k) &lt;= n </span><span class="cov7" title="321">{
                j := 2 * k
                if (j &lt; n) &amp;&amp; lt(arr[j], arr[j+1]) </span><span class="cov6" title="135">{
                        j++
                }</span>
                <span class="cov7" title="321">if !lt(arr[k], arr[j]) </span><span class="cov3" title="9">{
                        break</span>
                }
                <span class="cov7" title="312">swap(arr, k, j)
                k = j</span>
        }
}

func QuickSort[T any](arr []T) <span class="cov5" title="33">{
        Shuffle(arr)
        qsort(arr, 0, len(arr)-1)
}</span>

func qsort[T any](arr []T, lo, hi int) <span class="cov6" title="117">{
        if hi &lt;= lo </span><span class="cov5" title="48">{
                return
        }</span>
        <span class="cov5" title="69">if (hi - lo + 1) &lt;= 12 </span><span class="cov4" title="27">{
                InsertSort(arr)
                return
        }</span>
        <span class="cov5" title="42">j := pivot(arr, lo, hi)
        qsort(arr, lo, j-1)
        qsort(arr, j+1, hi)</span>
}

func pivot[T any](arr []T, lo, hi int) int <span class="cov5" title="42">{
        i, j, v := lo, hi, lo
        for </span><span class="cov7" title="197">{
                for ; lt(arr[i], arr[v]); i++ </span><span class="cov0" title="0">{
                        if i == hi </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov7" title="197">for ; lt(arr[v], arr[j]); j-- </span><span class="cov8" title="777">{
                        if j == lo </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov7" title="197">if i &gt;= j </span><span class="cov5" title="42">{
                        break</span>
                }
                <span class="cov6" title="155">swap(arr, i, j)</span>
        }
        <span class="cov5" title="42">swap(arr, lo, j)
        return j</span>
}

func MergeSort[T any](arr []T) <span class="cov5" title="33">{
        alen := len(arr)
        aux := make([]T, alen)
        copy(aux, arr)
        mrgsort(aux, arr, 0, alen-1)
}</span>

func mrgsort[T any](src []T, dst []T, lo, hi int) <span class="cov5" title="51">{
        if hi &lt;= lo </span><span class="cov3" title="6">{
                return
        }</span>
        <span class="cov5" title="45">if (hi - lo + 1) &lt;= 12 </span><span class="cov5" title="36">{
                InsertSort(src[lo : hi+1])
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov3" title="9">mid := lo + (hi-lo)/2
        mrgsort(dst, src, lo, mid)
        mrgsort(dst, src, mid+1, hi)
        merge(src, dst, lo, mid, hi)</span>
}

func merge[T any](src []T, dst []T, lo, mid, hi int) <span class="cov3" title="9">{
        if !gt(src[mid], src[mid+1]) </span><span class="cov3" title="9">{
                copy(dst[lo:hi+1], src[lo:hi+1])
                return
        }</span>
        <span class="cov0" title="0">i, j := lo, mid+1
        for k := lo; k &lt;= hi; k++ </span><span class="cov0" title="0">{
                if i &gt; mid </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                        continue</span>
                }
                <span class="cov0" title="0">if j &gt; hi </span><span class="cov0" title="0">{
                        dst[k] = src[i]
                        i++
                        continue</span>
                }
                <span class="cov0" title="0">if lt(src[j], src[i]) </span><span class="cov0" title="0">{
                        dst[k] = src[j]
                        j++
                }</span> else<span class="cov0" title="0"> {
                        dst[k] = src[i]
                        i++
                }</span>
        }
}

func ReverseSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov6" title="87">{
                min := i
                max := i
                for j := i + 1; j &lt; (alen - i); j++ </span><span class="cov8" title="635">{
                        if lt(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                        <span class="cov8" title="635">if gt(arr[j], arr[max]) </span><span class="cov8" title="635">{
                                max = j
                        }</span>
                }
                <span class="cov6" title="87">if max == i </span><span class="cov0" title="0">{
                        if min == (alen - i - 1) </span><span class="cov0" title="0">{
                                swap(arr, max, min)
                        }</span> else<span class="cov0" title="0"> {
                                swap(arr, (alen - i - 1), max)
                                swap(arr, i, min)
                        }</span>
                } else<span class="cov6" title="87"> {
                        swap(arr, i, min)
                        swap(arr, (alen - i - 1), max)
                }</span>
        }
}

func SelectSort[T any](arr []T) <span class="cov5" title="43">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov7" title="203">{
                min := i
                for j := i + 1; j &lt; alen; j++ </span><span class="cov9" title="1183">{
                        if lt(arr[j], arr[min]) </span><span class="cov0" title="0">{
                                min = j
                        }</span>
                }
                <span class="cov7" title="203">swap(arr, i, min)</span>
        }
}

func ShellSort[T any](arr []T) <span class="cov5" title="33">{
        alen := len(arr)
        h := 1
        for h &lt; (alen / 3) </span><span class="cov3" title="12">{
                h = 3*h + 1
        }</span>
        <span class="cov5" title="33">for h &gt; 0 </span><span class="cov5" title="45">{
                for i := h; i &lt; alen; i++ </span><span class="cov7" title="261">{
                        for j := i; j &gt;= h; j -= h </span><span class="cov7" title="261">{
                                if lt(arr[j], arr[j-h]) </span><span class="cov0" title="0">{
                                        swap(arr, j, j-h)
                                }</span> else<span class="cov7" title="261"> {
                                        break</span>
                                }
                        }
                }
                <span class="cov5" title="45">h = h / 3</span>
        }
}

func InsertSort[T any](arr []T) <span class="cov6" title="106">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov7" title="436">{
                for j := i; j &gt; 0; j-- </span><span class="cov9" title="1518">{
                        if lt(arr[j], arr[j-1]) </span><span class="cov9" title="1220">{
                                swap(arr, j, j-1)
                        }</span> else<span class="cov7" title="298"> {
                                break</span>
                        }
                }
        }
}

func BinarySearch[T any](arr []T, elem T) int <span class="cov2" title="3">{
        low := 0
        high := len(arr)
        for low &lt; high </span><span class="cov3" title="6">{
                mid := (low + ((high - low) / 2))
                val := arr[mid]
                if eq(val, elem) </span><span class="cov1" title="1">{
                        return mid
                }</span> else<span class="cov2" title="5"> if gt(val, elem) </span><span class="cov1" title="1">{
                        high = mid
                }</span> else<span class="cov2" title="4"> if lt(val, elem) </span><span class="cov2" title="4">{
                        low = mid + 1
                }</span>
        }
        <span class="cov1" title="2">return -1</span>
}

func Shuffle[T any](arr []T) <span class="cov5" title="33">{
        alen := len(arr)
        for i := 0; i &lt; alen; i++ </span><span class="cov6" title="172">{
                j := rand.Intn(i + 1)
                swap(arr, i, j)
        }</span>
}

func Reverse[T any](arr []T) <span class="cov2" title="3">{
        alen := len(arr)
        mid := alen / 2
        for i := 0; i &lt; mid; i++ </span><span class="cov3" title="9">{
                swap(arr, i, alen-i-1)
        }</span>
}

func Contained[T any](arr []T, elem T) int <span class="cov2" title="3">{
        for i, el := range arr </span><span class="cov2" title="5">{
                if eq(el, elem) </span><span class="cov1" title="1">{
                        return i
                }</span>
        }
        <span class="cov1" title="2">return -1</span>
}

func IsSorted[T any](arr []T) bool <span class="cov7" title="261">{
        alen := len(arr)
        for i := 1; i &lt; alen; i++ </span><span class="cov9" title="1053">{
                if lt(arr[i], arr[i-1]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov7" title="261">return true</span>
}

func swap[T any](arr []T, i, j int) <span class="cov10" title="2494">{
        arr[i], arr[j] = arr[j], arr[i]
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package array

import (
        _ "github.com/kselnaag/algos/types"
)

// ===========================
type Bag[T any] struct {
        arr  []T
        size int
        fwd  int
}

func NewBag[T any]() Bag[T] <span class="cov1" title="1">{
        return Bag[T]{
                arr:  make([]T, 0, 8),
                size: 0,
                fwd:  -1,
        }
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov5" title="4">{
        return b.size == 0
}</span>

func (b *Bag[T]) Size() int <span class="cov6" title="5">{
        return b.size
}</span>

func (b *Bag[T]) Add(val T) <span class="cov7" title="7">{
        b.arr = append(b.arr, val)
        b.size++
        b.fwd = -1
}</span>

func (b *Bag[T]) Next() T <span class="cov10" title="15">{
        b.fwd++
        if b.fwd == b.size </span><span class="cov1" title="1">{
                b.fwd = 0
        }</span>
        <span class="cov10" title="15">return b.arr[b.fwd]</span>
}

func (b *Bag[T]) Reverse() <span class="cov1" title="1">{
        Reverse(b.arr)
        b.fwd = -1
}</span>

func (b *Bag[T]) Drop() <span class="cov1" title="1">{
        b.arr = b.arr[:0]
        b.fwd = -1
        b.size = 0
}</span>

// ===========================
type Stack[T any] struct {
        arr  []T
        size int
        fwd  int
}

func NewStack[T any]() Stack[T] <span class="cov1" title="1">{
        return Stack[T]{
                arr:  make([]T, 0, 8),
                size: 0,
                fwd:  -1,
        }
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov6" title="5">{
        return s.size == 0
}</span>

func (s *Stack[T]) Size() int <span class="cov6" title="6">{
        return s.size
}</span>

func (s *Stack[T]) Push(val T) <span class="cov9" title="14">{
        s.arr = append(s.arr, val)
        s.size++
        s.fwd = -1
}</span>

func (s *Stack[T]) Pop() T <span class="cov7" title="8">{
        last := len(s.arr) - 1
        ret := s.arr[last]
        s.arr = s.arr[:last]
        s.size--
        s.fwd = -1
        return ret
}</span>

func (s *Stack[T]) Next() T <span class="cov7" title="8">{
        s.fwd++
        if s.fwd == s.size </span><span class="cov1" title="1">{
                s.fwd = 0
        }</span>
        <span class="cov7" title="8">return s.arr[s.fwd]</span>
}

func (s *Stack[T]) Reverse() <span class="cov1" title="1">{
        Reverse(s.arr)
        s.fwd = -1
}</span>

func (s *Stack[T]) Drop() <span class="cov1" title="1">{
        s.arr = s.arr[:0]
        s.fwd = -1
        s.size = 0
}</span>

// ===========================
type Queue[T any] struct {
        arr  []T
        size int
        fwd  int
}

func NewQueue[T any]() Queue[T] <span class="cov1" title="1">{
        return Queue[T]{
                arr:  make([]T, 0, 8),
                size: 0,
                fwd:  -1,
        }
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov6" title="5">{
        return q.size == 0
}</span>

func (q *Queue[T]) Size() int <span class="cov6" title="6">{
        return q.size
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov9" title="14">{
        q.arr = append(q.arr, val)
        q.size++
        q.fwd = -1
}</span>

func (q *Queue[T]) Deq() T <span class="cov7" title="8">{
        ret := q.arr[0]
        q.arr = q.arr[1:]
        q.size--
        q.fwd = -1
        return ret
}</span>

func (q *Queue[T]) Next() T <span class="cov7" title="8">{
        q.fwd++
        if q.fwd == q.size </span><span class="cov1" title="1">{
                q.fwd = 0
        }</span>
        <span class="cov7" title="8">return q.arr[q.fwd]</span>
}

func (q *Queue[T]) Reverse() <span class="cov1" title="1">{
        Reverse(q.arr)
        q.fwd = -1
}</span>

func (q *Queue[T]) Drop() <span class="cov1" title="1">{
        q.arr = q.arr[:0]
        q.fwd = -1
        q.size = 0
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package graph

import (
        "github.com/kselnaag/algos/array"
        "github.com/kselnaag/algos/math"
)

type UF struct {
        id    []int
        bag   array.Bag[int]
        count int
        size  int
}

func NewUF(n int) UF <span class="cov1" title="1">{
        n = math.Abs(n)
        arr := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov6" title="10">{
                arr[i] = i
        }</span>
        <span class="cov1" title="1">return UF{
                id:    arr,
                bag:   array.NewBag[int](),
                count: n,
                size:  n,
        }</span>
}

func (uf *UF) Union(p, q int) <span class="cov5" title="8">{
        pRoot := uf.Find(p)
        qRoot := uf.Find(q)
        if pRoot == qRoot </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov5" title="8">uf.id[qRoot] = pRoot
        uf.count--</span>
}

func (uf *UF) Find(p int) int <span class="cov10" title="50">{
        p = math.Abs(p)
        for p != uf.id[p] </span><span class="cov8" title="29">{
                uf.bag.Add(p)
                p = uf.id[p]
        }</span>
        // path compression
        <span class="cov10" title="50">blen := uf.bag.Size()
        for i := 0; i &lt; blen; i++ </span><span class="cov8" title="29">{
                t := uf.bag.Next()
                uf.id[t] = p
        }</span>
        <span class="cov10" title="50">uf.bag.Drop()
        return p</span>
}

func (uf *UF) Connected(p, q int) bool <span class="cov5" title="7">{
        return uf.Find(p) == uf.Find(q)
}</span>

func (uf *UF) Count() int <span class="cov3" title="3">{
        return uf.count
}</span>

func (uf *UF) Size() int <span class="cov3" title="3">{
        return uf.size
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package list

type node[T any] struct {
        val  T
        next *node[T]
}

func Reverse[T any](first *node[T]) *node[T] <span class="cov10" title="21">{
        if first == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="21">if first.next == nil </span><span class="cov4" title="3">{
                return first
        }</span>
        <span class="cov9" title="18">second := first.next
        root := Reverse(second)
        second.next = first
        first.next = nil
        return root</span>
}

// ===========================
type Bag[T any] struct {
        first *node[T]
        size  int
        fwd   *node[T]
}

func NewBag[T any]() Bag[T] <span class="cov1" title="1">{
        return Bag[T]{
                first: nil,
                size:  0,
                fwd:   nil,
        }
}</span>

func (b *Bag[T]) IsEmpty() bool <span class="cov5" title="4">{
        return b.size == 0
}</span>

func (b *Bag[T]) Size() int <span class="cov5" title="5">{
        return b.size
}</span>

func (b *Bag[T]) Add(val T) <span class="cov6" title="7">{
        first := b.first
        b.first = &amp;node[T]{val: val, next: first}
        b.size++
        b.fwd = b.first
}</span>

func (b *Bag[T]) Next() T <span class="cov9" title="15">{
        ret := b.fwd.val
        if b.fwd.next == nil </span><span class="cov3" title="2">{
                b.fwd = b.first
        }</span> else<span class="cov8" title="12"> {
                b.fwd = b.fwd.next
        }</span>
        <span class="cov8" title="14">return ret</span>
}

func (b *Bag[T]) Reverse() <span class="cov1" title="1">{
        b.fwd = Reverse(b.first)
        b.first = b.fwd
}</span>

func (b *Bag[T]) Drop() <span class="cov1" title="1">{
        b.first = nil
        b.size = 0
        b.fwd = nil
}</span>

// ===========================
type Stack[T any] struct {
        first *node[T]
        size  int
        fwd   *node[T]
}

func NewStack[T any]() Stack[T] <span class="cov1" title="1">{
        return Stack[T]{
                first: nil,
                size:  0,
                fwd:   nil,
        }
}</span>

func (s *Stack[T]) IsEmpty() bool <span class="cov5" title="5">{
        return s.size == 0
}</span>

func (s *Stack[T]) Size() int <span class="cov6" title="6">{
        return s.size
}</span>

func (s *Stack[T]) Push(val T) <span class="cov8" title="14">{
        first := s.first
        s.first = &amp;node[T]{val: val, next: first}
        s.size++
        s.fwd = s.first
}</span>

func (s *Stack[T]) Pop() T <span class="cov7" title="8">{
        ret := s.first.val
        s.first = s.first.next
        s.size--
        s.fwd = s.first
        return ret
}</span>

func (s *Stack[T]) Next() T <span class="cov7" title="8">{
        ret := s.fwd.val
        if s.fwd.next == nil </span><span class="cov1" title="1">{
                s.fwd = s.first
        }</span> else<span class="cov6" title="6"> {
                s.fwd = s.fwd.next
        }</span>
        <span class="cov6" title="7">return ret</span>
}

func (s *Stack[T]) Reverse() <span class="cov1" title="1">{
        s.fwd = Reverse(s.first)
        s.first = s.fwd
}</span>
func (s *Stack[T]) Drop() <span class="cov1" title="1">{
        s.first = nil
        s.size = 0
        s.fwd = nil
}</span>

// ===========================
type Queue[T any] struct {
        first *node[T]
        last  *node[T]
        size  int
        fwd   *node[T]
}

func NewQueue[T any]() Queue[T] <span class="cov1" title="1">{
        return Queue[T]{
                first: nil,
                last:  nil,
                size:  0,
                fwd:   nil,
        }
}</span>

func (q *Queue[T]) IsEmpty() bool <span class="cov5" title="5">{
        return q.size == 0
}</span>

func (q *Queue[T]) Size() int <span class="cov6" title="6">{
        return q.size
}</span>

func (q *Queue[T]) Enq(val T) <span class="cov8" title="14">{
        newnode := &amp;node[T]{val: val, next: nil}
        if q.size == 0 </span><span class="cov3" title="2">{
                q.first = newnode
        }</span> else<span class="cov8" title="12"> {
                q.last.next = newnode
        }</span>
        <span class="cov8" title="14">q.last = newnode
        q.size++
        q.fwd = q.first</span>
}

func (q *Queue[T]) Deq() T <span class="cov7" title="8">{
        ret := q.first.val
        q.first = q.first.next
        q.size--
        if (q.size == 0) || (q.size == 1) </span><span class="cov3" title="2">{
                q.last = q.first
        }</span>
        <span class="cov6" title="7">q.fwd = q.first
        return ret</span>
}

func (q *Queue[T]) Next() T <span class="cov7" title="8">{
        ret := q.fwd.val
        if q.fwd.next == nil </span><span class="cov1" title="1">{
                q.fwd = q.first
        }</span> else<span class="cov6" title="6"> {
                q.fwd = q.fwd.next
        }</span>
        <span class="cov6" title="7">return ret</span>
}

func (q *Queue[T]) Reverse() <span class="cov1" title="1">{
        q.last = q.first
        q.fwd = Reverse(q.first)
        q.first = q.fwd
}</span>

func (q *Queue[T]) Drop() <span class="cov1" title="1">{
        q.first = nil
        q.size = 0
        q.fwd = nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package math

import (
        I "github.com/kselnaag/algos/types"
)

func Harmonic(n int) float64 <span class="cov3" title="6">{
        if n &lt; 0 </span><span class="cov2" title="2">{
                panic("algos.math.Harmonic(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov3" title="4">sum := 0.0
        for i := 1; i &lt;= n; i++ </span><span class="cov10" title="261">{
                sum += 1.0 / float64(i)
        }</span>
        <span class="cov3" title="4">return sum</span>
}

// Newton square root
func Sqrt(c float64) float64 <span class="cov3" title="6">{
        if c &lt; 0 </span><span class="cov2" title="2">{
                panic("algos.math.Sqrt(x) -&gt; 'x' can not be negative")</span>
        }
        <span class="cov3" title="4">err := 1e-15
        t := c
        for Abs(t-c/t) &gt; (err * t) </span><span class="cov6" title="28">{
                t = (c/t + t) / 2.0
        }</span>
        <span class="cov3" title="4">return t</span>
}

func Abs[T I.Signed | I.Float](val T) T <span class="cov7" title="60">{
        if val &lt; 0 </span><span class="cov3" title="6">{
                return val * (-1)
        }</span> else<span class="cov7" title="54"> {
                return val
        }</span>
}

func IsPrime(n int) bool <span class="cov4" title="9">{
        if n &lt; 2 </span><span class="cov2" title="3">{
                return false
        }</span>
        <span class="cov3" title="6">for i := 2; (i * i) &lt;= n; i++ </span><span class="cov7" title="63">{
                if (n % i) == 0 </span><span class="cov2" title="2">{
                        return false
                }</span>
        }
        <span class="cov3" title="4">return true</span>
}

// Evklid NOD
func Gcd(p, q int) int <span class="cov4" title="10">{
        p, q = Abs(p), Abs(q)
        if q == 0 </span><span class="cov3" title="4">{
                return p
        }</span>
        <span class="cov3" title="6">r := p % q
        return Gcd(q, r)</span>
}

func Min[T I.Ord](x, y T) T <span class="cov4" title="9">{
        if x &lt; y </span><span class="cov3" title="4">{
                return x
        }</span> else<span class="cov3" title="5"> {
                return y
        }</span>
}

func Max[T I.Ord](x, y T) T <span class="cov4" title="9">{
        if x &gt; y </span><span class="cov3" title="4">{
                return x
        }</span> else<span class="cov3" title="5"> {
                return y
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
